<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ReactNative源码解析之启动流程]]></title>
    <url>%2F2019%2F11%2F07%2FReactNative%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[接触RN开发也快两年的时间了，期间也开发了5、6个APP了，ReactNative的版本也在快速的迭代着，今天重新出发，从源码解析一下App的启动流程，此次解析基于RN 0.60.5版本。 开始之前开始分析之前，新建一个名为RnDemo的空项目,RN版本选择0.60.5，通过查看项目的目录结构中Android部分会自动为我们生成MainActivity.java和MainApplication.java文件，我们的分析就从这两个文件入手。 Java部分，开始上传 1.首先看一下MainApplication文件，继承Application并实现了ReactApplication接口，主要做一写RN的初始化操作。 123456789101112131415161718192021222324252627282930313233343536public class MainApplication extends Application implements ReactApplication &#123; // 实现ReactApplication接口，创建ReactNativeHost成员变量，持有ReactInstanceManager实例，做一些初始化操作。 private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123; // 是否开启dev调试,及一些调试工具，比如redbox(红盒)，有时我们看到的报错 @Override public boolean getUseDeveloperSupport() &#123; return BuildConfig.DEBUG; &#125; // 返回app需要的ReactPackage，添加需要加载的模块，这个地方就是我们在项目中添加依赖包时需要添加第三方package的地方 @Override protected List&lt;ReactPackage&gt; getPackages() &#123; @SuppressWarnings(&quot;UnnecessaryLocalVariable&quot;) List&lt;ReactPackage&gt; packages = new PackageList(this).getPackages(); // Packages that cannot be autolinked yet can be added manually here, for example: // packages.add(new MyReactNativePackage()); return packages; &#125; @Override protected String getJSMainModuleName() &#123; return &quot;index&quot;; &#125; &#125;; @Override public ReactNativeHost getReactNativeHost() &#123; return mReactNativeHost; &#125; @Override public void onCreate() &#123; super.onCreate(); //SoLoader：加载C++底层库，准备解析JS。 SoLoader.init(this, /* native exopackage */ false); &#125;&#125; 2.接下来看一下MainActivity文件,继承自ReactActivity,ReactActivity作为JS页面的真正容器 1234567891011121314public class MainActivity extends ReactActivity &#123; /** * Returns the name of the main component registered from JavaScript. * This is used to schedule rendering of the component. */ @Override protected String getMainComponentName() &#123; // 返回组件名，和js入口注册名字一致 return &quot;RnDemo&quot;; &#125;&#125;对应的js模块注册名字中：AppRegistry.registerComponent(&quot;RnDemo&quot;, () =&gt; App); 3.继续，来看一下ReactActivity来， 1234567891011121314151617181920212223242526272829303132public abstract class ReactActivity extends AppCompatActivity implements DefaultHardwareBackBtnHandler, PermissionAwareActivity &#123; private final ReactActivityDelegate mDelegate; protected ReactActivity() &#123; mDelegate = createReactActivityDelegate(); &#125; /** * Called at construction time, override if you have a custom delegate implementation. */ protected ReactActivityDelegate createReactActivityDelegate() &#123; return new ReactActivityDelegate(this, getMainComponentName()); &#125; ... @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mDelegate.onCreate(savedInstanceState); &#125; protected final ReactNativeHost getReactNativeHost() &#123; return mDelegate.getReactNativeHost(); &#125; protected final ReactInstanceManager getReactInstanceManager() &#123; return mDelegate.getReactInstanceManager(); &#125; protected final void loadApp(String appKey) &#123; mDelegate.loadApp(appKey); &#125;&#125; 从以上代码可以看到，真正实现是在ReactActivityDelegate类中进行的。4.继续，我们重点看一下ReactActivityDelegate中的内容 123456789101112131415161718192021222324252627public class ReactActivityDelegate &#123; protected void onCreate(Bundle savedInstanceState) &#123;//mMainComponentName就是上面ReactActivity.getMainComponentName()返回的组件名 String mainComponentName = getMainComponentName(); if (mainComponentName != null) &#123;// 加载app页面 loadApp(mainComponentName); &#125;// 双击判断工具类 mDoubleTapReloadRecognizer = new DoubleTapReloadRecognizer(); &#125; protected void loadApp(String appKey) &#123;// 非空判断 if (mReactRootView != null) &#123; throw new IllegalStateException(&quot;Cannot loadApp while app is already running.&quot;); &#125;//创建ReactRootView作为根视图,它本质上是一个FrameLayout mReactRootView = createRootView();// 启动RN应用，并完成一些初始化设置 mReactRootView.startReactApplication( getReactNativeHost().getReactInstanceManager(), appKey, getLaunchOptions());// 将ReactRootView作为Activity的显示view getPlainActivity().setContentView(mReactRootView); &#125; 看看ReactActivityDelegate做了那些工作： 1231.创建ReactRootView作为根视图2.startReactApplication启动RN流程3.将ReactRootView作为ReactActivity的内容显示view 由此看来ReactRootView是个关键，进入ReactRootView类继续看一下启动RN的startReactApplication方法，它接受三个参数:ReactInstanceManager,appName,启动的设置参数launchOptions, 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Schedule rendering of the react component rendered by the JS application from the given JS * module (@&#123;param moduleName&#125;) using provided &#123;@param reactInstanceManager&#125; to attach to the * JS context of that manager. Extra parameter &#123;@param launchOptions&#125; can be used to pass initial * properties for the react component. */ public void startReactApplication( ReactInstanceManager reactInstanceManager, String moduleName, @Nullable Bundle initialProperties, @Nullable String initialUITemplate) &#123; Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;startReactApplication&quot;); try &#123; UiThreadUtil.assertOnUiThread(); // TODO(6788889): Use POJO instead of bundle here, apparently we can&apos;t just use WritableMap // here as it may be deallocated in native after passing via JNI bridge, but we want to reuse // it in the case of re-creating the catalyst instance Assertions.assertCondition( mReactInstanceManager == null, &quot;This root view has already been attached to a catalyst instance manager&quot;); // reactInstanceManage实例,管理React实例 mReactInstanceManager = reactInstanceManager; // js注册的name,同ReactActivity.getMainComponentName()与AppRegistry.registerComponent()放回一致 mJSModuleName = moduleName; // 是Native向JS传递的数据，以后可能由POJO代替，默认是null，需要的话要重写createReactActivityDelegate ，并重写其中getLaunchOptions方法 mAppProperties = initialProperties; mInitialUITemplate = initialUITemplate; if (mUseSurface) &#123; // TODO initialize surface here &#125; // 创建RN的上下文ReactContext if (!mReactInstanceManager.hasStartedCreatingInitialContext()) &#123; mReactInstanceManager.createReactContextInBackground(); &#125; //宽高计算完成后添加布局监听 attachToReactInstanceManager(); &#125; finally &#123; Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE); &#125; &#125; 接下来，进入ReactInstanceManger类看一下createReactContextInBackground方法, 123456789101112131415161718192021/** * Trigger react context initialization asynchronously in a background async task. This enables * applications to pre-load the application JS, and execute global code before * &#123;@link ReactRootView&#125; is available and measured. This should only be called the first time the * application is set up, which is enforced to keep developers from accidentally creating their * application multiple times without realizing it. * * Called from UI thread. */ @ThreadConfined(UI) public void createReactContextInBackground() &#123; Log.d(ReactConstants.TAG, &quot;ReactInstanceManager.createReactContextInBackground()&quot;); Assertions.assertCondition( !mHasStartedCreatingInitialContext, &quot;createReactContextInBackground should only be called when creating the react &quot; + &quot;application for the first time. When reloading JS, e.g. from a new file, explicitly&quot; + &quot;use recreateReactContextInBackground&quot;); // 仅在应用首次启动是调用，防止开发人员意外的创建其他应用 mHasStartedCreatingInitialContext = true; recreateReactContextInBackgroundInner(); &#125; createReactContextInBackground方法仅会在首次启动时调用，重新加载(reloaded)app时，会调用recreateReactContextInBackground(),两个方法都会调用recreateReactContextInBackgroundInner(), 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@ThreadConfined(UI) private void recreateReactContextInBackgroundInner() &#123; Log.d(ReactConstants.TAG, &quot;ReactInstanceManager.recreateReactContextInBackgroundInner()&quot;); PrinterHolder.getPrinter() .logMessage(ReactDebugOverlayTags.RN_CORE, &quot;RNCore: recreateReactContextInBackground&quot;); //UI线程 UiThreadUtil.assertOnUiThread();//开发模式，实现在线更新Bundle，晃动弹出调试菜单等功能，这一部分属于调试功能流程。 if (mUseDeveloperSupport &amp;&amp; mJSMainModulePath != null) &#123; final DeveloperSettings devSettings = mDevSupportManager.getDevSettings(); // If remote JS debugging is enabled, load from dev server. if (mDevSupportManager.hasUpToDateJSBundleInCache() &amp;&amp; !devSettings.isRemoteJSDebugEnabled()) &#123; // If there is a up-to-date bundle downloaded from server, // with remote JS debugging disabled, always use that.// 调试模式，从服务器加载jsBundle onJSBundleLoadedFromServer(null); return; &#125; if (!Systrace.isTracing(TRACE_TAG_REACT_APPS | TRACE_TAG_REACT_JS_VM_CALLS)) &#123;// 加载服务bundle if (mBundleLoader == null) &#123; mDevSupportManager.handleReloadJS(); &#125; else &#123; mDevSupportManager.isPackagerRunning( new PackagerStatusCallback() &#123; @Override public void onPackagerStatusFetched(final boolean packagerIsRunning) &#123; UiThreadUtil.runOnUiThread( new Runnable() &#123; @Override public void run() &#123; if (packagerIsRunning) &#123; mDevSupportManager.handleReloadJS(); &#125; else &#123; // If dev server is down, disable the remote JS debugging. devSettings.setRemoteJSDebugEnabled(false); recreateReactContextInBackgroundFromBundleLoader(); &#125; &#125; &#125;); &#125; &#125;); &#125; return; &#125; &#125; // 加载本地bundle recreateReactContextInBackgroundFromBundleLoader(); &#125; recreateReactContextInBackgroundFromBundleLoader方法向下调用recreateReactContextInBackground方法 12345678910111213141516171819202122232425@ThreadConfined(UI) private void recreateReactContextInBackground(//C++和JS双向通信的中转站 JavaScriptExecutorFactory jsExecutorFactory,// bundle加载器，根据ReactNativeHost中的配置决定从哪里加载bundle文件 JSBundleLoader jsBundleLoader) &#123; Log.d(ReactConstants.TAG, &quot;ReactInstanceManager.recreateReactContextInBackground()&quot;); UiThreadUtil.assertOnUiThread(); //创建ReactContextInitParams对象 final ReactContextInitParams initParams = new ReactContextInitParams( jsExecutorFactory, jsBundleLoader); if (mCreateReactContextThread == null) &#123; // 在newThread实例化ReactContext runCreateReactContextOnNewThread(initParams); &#125; else &#123; mPendingReactContextInitParams = initParams; &#125; &#125; //runCreateReactContextOnNewThread()方法中内容final ReactApplicationContext reactApplicationContext = createReactContext( initParams.getJsExecutorFactory().create(), initParams.getJsBundleLoader()); 在runCreateReactContextOnNewThread方法中，我们看到是ReactInstanceManager.createReactContext方法最终创建了ReactApplicationContext,我们继续看createReactContext()方法,有关此方法的2个参数： JSCJavaScriptExecutor jsExecutor：JSCJavaScriptExecutor继承于JavaScriptExecutor，当该类被加载时，它会自动去加载”reactnativejnifb.so”库，并会调用Native方法initHybrid()初始化C++层RN与JSC通信的框架。JSBundleLoader jsBundleLoader：缓存了JSBundle的信息，封装了上层加载JSBundle的相关接口，CatalystInstance通过其简介调用ReactBridge去加载JS文件，不同的场景会创建不同的加载器，具体可以查看类JSBundleLoader。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private ReactApplicationContext createReactContext( JavaScriptExecutor jsExecutor, JSBundleLoader jsBundleLoader) &#123; Log.d(ReactConstants.TAG, &quot;ReactInstanceManager.createReactContext()&quot;); ReactMarker.logMarker(CREATE_REACT_CONTEXT_START, jsExecutor.getName());// ReactApplicationContext 是reactContext的包装类 final ReactApplicationContext reactContext = new ReactApplicationContext(mApplicationContext); NativeModuleCallExceptionHandler exceptionHandler = mNativeModuleCallExceptionHandler != null ? mNativeModuleCallExceptionHandler : mDevSupportManager; reactContext.setNativeModuleCallExceptionHandler(exceptionHandler);//创建JavaModule注册表Builder，用来创建JavaModule注册表，JavaModule注册表将所有的JavaModule注册到CatalystInstance中。 NativeModuleRegistry nativeModuleRegistry = processPackages(reactContext, mPackages, false);//jsExecutor、nativeModuleRegistry、nativeModuleRegistry等各种参数处理好之后，开始构建CatalystInstanceImpl实例。 CatalystInstanceImpl.Builder catalystInstanceBuilder = new CatalystInstanceImpl.Builder() .setReactQueueConfigurationSpec(ReactQueueConfigurationSpec.createDefault()) .setJSExecutor(jsExecutor)// js执行通信类 .setRegistry(nativeModuleRegistry)//java模块注册表 .setJSBundleLoader(jsBundleLoader)// bundle加载器 .setNativeModuleCallExceptionHandler(exceptionHandler); // 异常处理器 ReactMarker.logMarker(CREATE_CATALYST_INSTANCE_START); // CREATE_CATALYST_INSTANCE_END is in JSCExecutor.cpp Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;createCatalystInstance&quot;); final CatalystInstance catalystInstance; try &#123; catalystInstance = catalystInstanceBuilder.build(); &#125; finally &#123; Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE); ReactMarker.logMarker(CREATE_CATALYST_INSTANCE_END); &#125; if (mJSIModulePackage != null) &#123; catalystInstance.addJSIModules(mJSIModulePackage .getJSIModules(reactContext, catalystInstance.getJavaScriptContextHolder())); &#125; if (mBridgeIdleDebugListener != null) &#123; catalystInstance.addBridgeIdleDebugListener(mBridgeIdleDebugListener); &#125; if (Systrace.isTracing(TRACE_TAG_REACT_APPS | TRACE_TAG_REACT_JS_VM_CALLS)) &#123;//调用CatalystInstanceImpl的Native方法把Java Registry转换为Json，再由C++层传送到JS层。 catalystInstance.setGlobalVariable(&quot;__RCTProfileIsProfiling&quot;, &quot;true&quot;); &#125; ReactMarker.logMarker(ReactMarkerConstants.PRE_RUN_JS_BUNDLE_START); Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;runJSBundle&quot;);//通过CatalystInstance开始加载JS Bundle catalystInstance.runJSBundle(); Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE); //关联ReacContext与CatalystInstance reactContext.initializeWithInstance(catalystInstance); return reactContext; &#125; createReactContext方法中用catalystInstance.runJSBundle() 来加载 JS bundle 12345@Override public void runJSBundle() &#123; ...省略代码 mJSBundleLoader.loadScript(CatalystInstanceImpl.this);&#125; 查看loadScript方法，参数JSBundleLoaderDelegate接口的实现类CatalystInstanceImpl,我们假设调用了loadScriptFromAssets方法， 123456@Override public void loadScriptFromAssets(AssetManager assetManager, String assetURL, boolean loadSynchronously) &#123; mSourceURL = assetURL; jniLoadScriptFromAssets(assetManager, assetURL, loadSynchronously); &#125;private native void jniLoadScriptFromAssets(AssetManager assetManager, String assetURL, boolean loadSynchronously); CatalystInstanceImpl.java最终还是调用C++层的CatalystInstanceImpl.cpp去加载JS Bundle。接下来看一下CatalystInstance的实现类CatalystInstanceImpl的构造方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private CatalystInstanceImpl( final ReactQueueConfigurationSpec reactQueueConfigurationSpec, final JavaScriptExecutor jsExecutor, final NativeModuleRegistry nativeModuleRegistry, final JSBundleLoader jsBundleLoader, NativeModuleCallExceptionHandler nativeModuleCallExceptionHandler) &#123; Log.d(ReactConstants.TAG, &quot;Initializing React Xplat Bridge.&quot;); Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;createCatalystInstanceImpl&quot;); //Native方法，用来创建JNI相关状态，并返回mHybridData mHybridData = initHybrid(); //RN中的三个线程：Native Modules Thread、JS Thread、UI Thread，都是通过Handler来管理的。 mReactQueueConfiguration = ReactQueueConfigurationImpl.create( reactQueueConfigurationSpec, new NativeExceptionHandler()); mBridgeIdleListeners = new CopyOnWriteArrayList&lt;&gt;(); mNativeModuleRegistry = nativeModuleRegistry; mJSModuleRegistry = new JavaScriptModuleRegistry(); mJSBundleLoader = jsBundleLoader; mNativeModuleCallExceptionHandler = nativeModuleCallExceptionHandler; mNativeModulesQueueThread = mReactQueueConfiguration.getNativeModulesQueueThread(); mTraceListener = new JSProfilerTraceListener(this); Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE); Log.d(ReactConstants.TAG, &quot;Initializing React Xplat Bridge before initializeBridge&quot;); Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;initializeCxxBridge&quot;);//Native方法，调用initializeBridge()方法，并创建BridgeCallback实例，初始化Bridge。 initializeBridge( new BridgeCallback(this), jsExecutor, mReactQueueConfiguration.getJSQueueThread(), mNativeModulesQueueThread, mNativeModuleRegistry.getJavaModules(this), mNativeModuleRegistry.getCxxModules()); Log.d(ReactConstants.TAG, &quot;Initializing React Xplat Bridge after initializeBridge&quot;); Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE); mJavaScriptContextHolder = new JavaScriptContextHolder(getJavaScriptContext()); &#125;//在C++层初始化通信桥ReactBridge private native void initializeBridge( ReactCallback callback, JavaScriptExecutor jsExecutor, MessageQueueThread jsQueue, MessageQueueThread moduleQueue, Collection&lt;JavaModuleWrapper&gt; javaModules, Collection&lt;ModuleHolder&gt; cxxModules); 参数解读： ReactCallback:CatalystInstanceImpl的静态内部类ReactCallback，负责接口回调 JavaScriptExecutor: js执行器，将js的调用传给c++层 MessageQueueThread jsQueue：js线程 MessageQueueThread moduleQueue： java线程 javaModules： java module cxxModules: c++ module好累，😀，继续，我们去c++层看一下，在项目的node_modules/react-native/ReactAndroid/src/main/jni/react/jni可以找到CatalystInstanceImpl.cpp看一下CatalystInstanceImpl::jniLoadScriptFromAssets1234567891011121314151617181920212223242526272829void CatalystInstanceImpl::jniLoadScriptFromAssets( jni::alias_ref&lt;JAssetManager::javaobject&gt; assetManager, const std::string&amp; assetURL, bool loadSynchronously) &#123; const int kAssetsLength = 9; // strlen(&quot;assets://&quot;);//获取source js Bundle的路径名，这里默认的就是index.android.bundle auto sourceURL = assetURL.substr(kAssetsLength);//assetManager是Java层传递过来的AssetManager，调用JSLoade.cpo里的extractAssetManager()方法，extractAssetManager()再 //调用android/asset_manager_jni.h里的AssetManager_fromJava()方法获取AssetManager对象。 auto manager = extractAssetManager(assetManager);// 调用JSloader.cpp的loadScriptFromAssets方法，读取js Bundle里面的内容 auto script = loadScriptFromAssets(manager, sourceURL);// unbundle命令打包判断，build.gradle默认里是bundle打包方式。 if (JniJSModulesUnbundle::isUnbundle(manager, sourceURL)) &#123; auto bundle = JniJSModulesUnbundle::fromEntryFile(manager, sourceURL); auto registry = RAMBundleRegistry::singleBundleRegistry(std::move(bundle)); instance_-&gt;loadRAMBundle( std::move(registry), std::move(script), sourceURL, loadSynchronously); return; &#125; else if (Instance::isIndexedRAMBundle(&amp;script)) &#123; instance_-&gt;loadRAMBundleFromString(std::move(script), sourceURL); &#125; else &#123;//bundle命令打包走此流程，instance_是Instan.h中类的实例 instance_-&gt;loadScriptFromString(std::move(script), sourceURL, loadSynchronously); &#125;&#125; 在项目node_modules/react-native/ReactCommon的cxxReact的NativeToJsBridge.cpp文件： 1234567891011121314151617181920212223242526272829void NativeToJsBridge::loadApplication( std::unique_ptr&lt;JSModulesUnbundle&gt; unbundle, std::unique_ptr&lt;const JSBigString&gt; startupScript, std::string startupScriptSourceURL) &#123; //获取一个MessageQueueThread，探后在线程中执行一个Task。 runOnExecutorQueue( m_mainExecutorToken, [unbundleWrap=folly::makeMoveWrapper(std::move(unbundle)), startupScript=folly::makeMoveWrapper(std::move(startupScript)), startupScriptSourceURL=std::move(startupScriptSourceURL)] (JSExecutor* executor) mutable &#123; auto unbundle = unbundleWrap.move(); if (unbundle) &#123; executor-&gt;setJSModulesUnbundle(std::move(unbundle)); &#125; //executor从runOnExecutorQueue()返回的map中取得，与OnLoad中的JSCJavaScriptExecutorHolder对应，也与 //Java中的JSCJavaScriptExecutor对应。它的实例在JSIExecutor.cpp中实现。 executor-&gt;loadApplicationScript(std::move(*startupScript), std::move(startupScriptSourceURL)); &#125;);&#125;关于unbundle命令&lt;unbundle命令，使用方式和bundle命令完全相同。unbundle命令是在bundle命令的基础上增加了一项功能，除了生成整合JS文件index.android.bundle外，还会生成各个单独的未整合JS文件（但会被优化），全部放在js-modules目录下，同时会生成一个名为UNBUNDLE的标识文件，一并放在其中。UNBUNDLE标识文件的前4个字节固定为0xFB0BD1E5，用于加载前的校验。 进入项目node_modules/react-native/ReactCommon/jsiexecutor/jsireact/JSIExecutor.cpp进一步调用JSIExecutor.cpp的loadApplicationScript()方法。 1234//解释执行JSruntime_-&gt;evaluateJavaScript( std::make_unique&lt;BigStringBuffer&gt;(std::move(script)), sourceURL); flush(); flushedQueueJS支线的是MessageQueue.js的flushedQueue()方法，此时JS已经被加载到队列中，等待Java层来驱动它。加载完JS后，返回reactApplicationContext，我们继续跟进它的实现。我们回到ReactInstanceManager类的runCreateReactContextOnNewThread方法中，看到setupReactContext()方法，进入之后可以看到attachRootViewToInstance(reactRoot)方法，进入后 1234567891011121314151617181920212223242526272829private void attachRootViewToInstance(final ReactRoot reactRoot) &#123; Log.d(ReactConstants.TAG, &quot;ReactInstanceManager.attachRootViewToInstance()&quot;); Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;attachRootViewToInstance&quot;); UIManager uiManagerModule = UIManagerHelper.getUIManager(mCurrentReactContext, reactRoot.getUIManagerType()); @Nullable Bundle initialProperties = reactRoot.getAppProperties(); final int rootTag = uiManagerModule.addRootView( reactRoot.getRootViewGroup(), initialProperties == null ? new WritableNativeMap() : Arguments.fromBundle(initialProperties), reactRoot.getInitialUITemplate()); reactRoot.setRootViewTag(rootTag); // 启动入口 reactRoot.runApplication(); Systrace.beginAsyncSection( TRACE_TAG_REACT_JAVA_BRIDGE, &quot;pre_rootView.onAttachedToReactInstance&quot;, rootTag); UiThreadUtil.runOnUiThread( new Runnable() &#123; @Override public void run() &#123; Systrace.endAsyncSection( TRACE_TAG_REACT_JAVA_BRIDGE, &quot;pre_rootView.onAttachedToReactInstance&quot;, rootTag); reactRoot.onStage(ReactStage.ON_ATTACH_TO_INSTANCE); &#125; &#125;); Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE); &#125; catalystInstance.getJSModule(AppRegistry.class)AppRegistry.class是JS层暴露给Java层的接口方法，它的真正实现在AppRegistry.js里，AppRegistry.js是运行所有RN应用的JS层入口， 12345678910111213141516171819202122232425262728293031323334353637runApplication(appKey: string, appParameters: any): void &#123; const msg = &apos;Running application &quot;&apos; + appKey + &apos;&quot; with appParams: &apos; + JSON.stringify(appParameters) + &apos;. &apos; + &apos;__DEV__ === &apos; + String(__DEV__) + &apos;, development-level warning are &apos; + (__DEV__ ? &apos;ON&apos; : &apos;OFF&apos;) + &apos;, performance optimizations are &apos; + (__DEV__ ? &apos;OFF&apos; : &apos;ON&apos;); infoLog(msg); BugReporting.addSource( &apos;AppRegistry.runApplication&apos; + runCount++, () =&gt; msg, ); invariant( runnables[appKey] &amp;&amp; runnables[appKey].run, &apos;Application &apos; + appKey + &apos; has not been registered.\n\n&apos; + &quot;Hint: This error often happens when you&apos;re running the packager &quot; + &apos;(local dev server) from a wrong folder. For example you have &apos; + &apos;multiple apps and the packager is still running for the app you &apos; + &apos;were working on before.\nIf this is the case, simply kill the old &apos; + &apos;packager instance (e.g. close the packager terminal window) &apos; + &apos;and start the packager in the correct app folder (e.g. cd into app &apos; + &quot;folder and run &apos;npm start&apos;).\n\n&quot; + &apos;This error can also happen due to a require() error during &apos; + &apos;initialization or failure to call AppRegistry.registerComponent.\n\n&apos;, ); SceneTracker.setActiveScene(&#123;name: appKey&#125;); runnables[appKey].run(appParameters); &#125;, 😀，基本到这，就会去调用JS进行组件渲染，再通过Java层的UIManagerModule将JS组件转换为Android组件，最终显示在ReactRootView上，即完成启动过程。😀阅读源代码还是挺耗时的事情，哈哈。 同步更新至个人公众号及博客。CSDN:https://blog.csdn.net/wayne214公众号：君伟说。]]></content>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Androidgradle编译报错:Cause:org.jetbrains.plugins.gradle]]></title>
    <url>%2F2019%2F11%2F06%2FAndroid%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[新建了一个基于ReactNative version0.60.5的新项目，在使用Android Studio编译项目的时候build了如下错误： 1org.jetbrains.plugins.gradle.tooling.util.ModuleComponentIdentifierImpl.getModuleIdentifier() 从报错类型看是gradle的版本问题，google后发现是应该是android的IDE版本(3.1.2)太低，和项目的gradle版本无法兼容导致。项目中的版本为，通过查看/gradle/wrapper/gradle-wrapper.properties 文件中的内容，看到下面是5.4.1 12345distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zipzipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/dists 考虑项目兼容问题，目前考虑降低gradle的版本，改下下面这样： 12345distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-4.10.1-all.zipzipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/dists 你以为这样就完事了？too young too simple.重新build就报了如下错误： 1Could not get unknown property &apos;mergeResourcesProvider&apos; for object of type com.android.build.gradle.internal.api.ApplicationVariantImpl. 怎么办？接着搞呗。进入Android根目录的build.gradle文件，修改如下： 1234567dependencies &#123; classpath(&quot;com.android.tools.build:gradle:3.4.1&quot;) // 修改上面的gradle版本成下面的： classpath(&quot;com.android.tools.build:gradle:3.3.0&quot;) // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125; 重新build项目就ok了。 欢迎关注我的公众号：君伟说。个人博客：https://blog.csdn.net/wayne214]]></content>
      <tags>
        <tag>“Android”</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter build failed android]]></title>
    <url>%2F2019%2F10%2F25%2FFlutterandroidbuild%2F</url>
    <content type="text"><![CDATA[笔者作为小白入坑Flutter,在Flutter写了一个入门demo,在进行Android编译的时候报错code如下： 1Daemon: AAPT2 aapt2-3.2.1-4818971-osx Daemon #0 具体报错截图如下： 解决方案：进入项目工程的android/app/build.gradle文件，修改编译的sdk版本为28,重新编译即可。代码如下： 1compileSdkVersion 28 欢迎关注个人公众号：君伟说。个人网站：https://wayne214.github.io一个有温度的公众号，扫码关注哦。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来了，来了，真的来了，ReactNative集成百度语音开源库]]></title>
    <url>%2F2019%2F10%2F22%2F%E6%9D%A5%E4%BA%86%EF%BC%8C%E6%9D%A5%E4%BA%86%EF%BC%8C%E7%9C%9F%E7%9A%84%E6%9D%A5%E4%BA%86%EF%BC%8CReactNative%E9%9B%86%E6%88%90%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E5%BC%80%E6%BA%90%E5%BA%93%2F</url>
    <content type="text"><![CDATA[笔者在之前这篇文章中ReactNative集成百度语音合成介绍了在项目中如何集成百度语音合成步骤和部分代码。今天重(you)磅(dian)推(peng)出(zhang)百度语音合成开源库# react-native-baidu-vtts ,目前只做了Android端的集成，后期补上IOS端集成，开源不易，欢迎大家star Github地址：react-native-baidu-vtts开源的初衷： 虽然能够在项目中集成，但是使用起来还是需要写Android类和js代码，相对有些繁琐 部分读者在上一篇文章反馈，按照笔者的步骤集成中出现一些问题，比较闹心 网上也有一些类似的开源库，存在如下一下问题：没有使用文档、根本就不是一个库、兼容性问题(Android机型)ReactNative集成百度语音合成文章有也有提到。 一直想开源。。。准备工作请参考ReactNative集成百度语音合成的“兵马未动粮草先行”模块安装12345npm install react-native-baidu-vtts --saveoryarn add react-native-baidu-vtts 自动添加原生依赖react-native link react-native-baidu-vtts 使用12345678910111213141516171819202122232425262728import RNBaiduvoice from &apos;react-native-baidu-vtts&apos;;// TODO: What to do with the module?class App extends Component&#123; componentDidMount() &#123; // 填写百度语音官网申请的appid, apikey, secretkey const String appid = &apos;&apos; const String apikey = &apos;&apos; const String secretkey = &apos;&apos; RNBaiduvoice.initBaiduTTS(appid,apikey,secretkey) &#125; _speechText = () =&gt; &#123; RNBaiduvoice.speak(&apos;百度语音&apos;) &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &#123;/*&lt;TwoList/&gt;*/&#125; &lt;TouchableOpacity onPress=&#123;this._speechText&#125;&gt; &lt;Text style=&#123;&#123;fontSize: 20, height: 30&#125;&#125;&gt;测试语音&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125;&#125; 最后欢迎关注我的公众号：君伟说， 一个有温度的公众号。]]></content>
      <categories>
        <category>开源软件</category>
      </categories>
      <tags>
        <tag>react-native-baidu-vtts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源ReactNative卡片式(Cards)组件，你值得拥有]]></title>
    <url>%2F2019%2F10%2F15%2F%E5%BC%80%E6%BA%90ReactNative%E5%8D%A1%E7%89%87%E5%BC%8F-Cards-%E7%BB%84%E4%BB%B6%EF%BC%8C%E4%BD%A0%E5%80%BC%E5%BE%97%E6%8B%A5%E6%9C%89%2F</url>
    <content type="text"><![CDATA[开源一个跨端的卡片式设计(Cards)的组件,在Android中是Material Design中有一种很个性的设计概念，在使用React-Native跨平台的开发框架中，卡片样式在IOS平台通过设置View的样式就可以实现类似的效果,比如这样： 123456789101112&lt;View style=&#123;&#123; shadowOffset: &#123; // 设置阴影偏移量 width: 0, height: 4 &#125;, shadowRadius: 4, // 设置阴影模糊半径 shadowOpacity: 0.13, // 设置阴影的不透明度 borderRadius: 10, // 设置圆角 shadowColor: &apos;rgba(96,96,96,1)&apos; // 设置阴影色 &#125; &#123;...props&#125; /&gt; 基于此，此开源组件，在IOS端即采用了RN平台提供的阴影样式属性来实现卡片样式；在Android端采用Android原生support库在V7引入的原生CardView UI组件，来实现卡片样式设计的组件​。Github项目地址： react-native-cardview-wayne 使用​：123456789101112131415161718192021import RNCardview from &apos;react-native-cardview-wayne&apos;;export default class App extends Component &#123; render() &#123; return ( &lt;CardView cardElevation=&#123;4&#125; maxCardElevation=&#123;4&#125; radius=&#123;10&#125; backgroundColor=&#123;&apos;#ffffff&apos;&#125;&gt; &lt;View style=&#123;&#123;padding:10&#125;&#125;&gt; &lt;View&gt; &lt;Text&gt;CardView for iOS and Android&lt;/Text&gt; &lt;/View&gt; &lt;View&gt; &lt;Text&gt;This is test&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/CardView&gt; ); &#125;&#125;; 效果如下：Android： ios: 此次重造一个轮子，目的在于学习封装一个包含原生组件的ReactNative包的开发过程，并发布到npm仓库。 个人公众号：君伟说， 欢迎大家关注。]]></content>
      <tags>
        <tag>开源软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5分钟简单了解React-Hooks]]></title>
    <url>%2F2019%2F10%2F09%2F5%E5%88%86%E9%92%9F%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3React-Hooks%2F</url>
    <content type="text"><![CDATA[首先附上官网正文😀：React Hooks Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class. 简单讲就是说，Hooks是在React 16.8版本中新增加的特性。可以让你通过不谢一个类class,就可以使用State和其他React特性。另外使用ReactNative开发的小伙伴需要注意一下，就是在ReactNative 0.59正式版才开始支持Hooks. React 16.8.0 is the first release to support Hooks. When upgrading, don’t forget to update all packages, including React DOM. React Native supports Hooks since the 0.59 release of React Native. 现在通过写一个简单的案例来说明一下，下面代码中useState方法就是React已经内部实现的hook,是一个状态钩子。 1.使用class的方式,通过一个按钮点击改变文字12345678910111213141516171819202122232425262728293031import React, &#123;Component&#125; from &apos;react&apos;import &#123; Text, View, TouchableOpacity&#125; from &apos;react-native&apos;export default class demo_class extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; text: &apos;this is class demo&apos; &#125; &#125; _changeTheDefaultText = () =&gt; &#123; this.setState(&#123; text: &apos;this is the new text&apos; &#125;) &#125; render() &#123; const &#123;text&#125; = this.state return ( &lt;View&gt; &lt;Text style=&#123;&#123;fontSize: 20, color: &apos;red&apos;&#125;&#125;&gt;&#123;text&#125;&lt;/Text&gt; &lt;TouchableOpacity onPress=&#123;this._changeTheDefaultText&#125;&gt; &lt;Text style=&#123;&#123;fontSize: 20, color: &apos;red&apos;&#125;&#125;&gt;改变文字&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;&#125; 2.同样的方式，使用hook来实现12345678910111213141516171819202122232425import React, &#123;useState&#125; from &apos;react&apos;import &#123; Text, View, TouchableOpacity&#125; from &apos;react-native&apos;const demoHooks = () =&gt; &#123; // 初始值 const [text, setText] = useState(&apos;this is hook demo&apos;) // 方法 _changeTheDefaultText = () =&gt; &#123; return setText(&apos;this is the new text&apos;) &#125; return ( &lt;View&gt; &lt;Text style=&#123;&#123;fontSize: 20, color: &apos;red&apos;&#125;&#125;&gt;&#123;text&#125;&lt;/Text&gt; &lt;TouchableOpacity onPress=&#123;this._changeTheDefaultText&#125;&gt; &lt;Text style=&#123;&#123;fontSize: 20, color: &apos;red&apos;&#125;&#125;&gt;改变文字&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; )&#125;export default demoHooks 通过上面两个简单的例子，直观看使用hook后的代码数明显比使用class完成的少，但实现的是同样的功能。是不是很欣喜呢？ useState()这个函数接受一个初始值作为参数，和class中this.state设置的值一样。返回一个数组，数组的第一个成员是我们自定义的变量，就是状态的当前值，比如，例子中text;第二个成员是一个函数，用来修改state,通常约定set前缀加上自定义状态的变量名，比如例子中的setText 3.新增加的这个hooks特性，没有突破性的改变 是一个可选项。你完全可以尝试使用Hooks重写任何已有代码 100%向后兼容。Hooks并没有带来任何突破性的改变。 hooks只是提供了一个多选项，一个more API,来优化你的代码， react 官方也没有打算要完全移除类class]]></content>
      <tags>
        <tag>react-hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native-border-radius-image]]></title>
    <url>%2F2019%2F10%2F08%2Freact-native-border-radius-image%2F</url>
    <content type="text"><![CDATA[大家好，十一假期biu的一下就过去了，相信大家都没有玩的尽兴，没关系，我们还有周六周日双休日(不加班)，或者再坚持三个月就到了2020年的元旦了， 是不是发现时间过得太快了。好了，开工了，😀。笔者在ReactNative之Image在Android设置圆角图片变形问题这篇文章中提到了安卓端设置图片圆角的解决办法，但是还需要大家复制代码，不太友好(太麻烦，能不能npm一下，😀)。鉴于这种情况，今天做了一个开源的组件# react-native-border-radius-image， 大家可以试试看效果如何。欢迎大家star哦 使用1、安装依赖1yarn add react-native-border-radius-image 2、使用123456789101112131415161718// 导入包import RoundImage from &apos;react-native-border-radius-image&apos;// 页面中引用, render 方法中// Icon 为设置的默认logorender() &#123; const imgUrl = itemData.logo_url ? &#123;uri: itemData.logo_url&#125; : Icon; return( &lt;RoundImage source=&#123;imgUrl&#125; size=&#123;40&#125; style=&#123;&#123;alignSelf: &apos;flex-start&apos;, marginTop: 2,&#125;&#125; /&gt; )&#125; 3、有图有真相 这样是不是更加愉快的使用了，😀。如果帮助了您，欢迎大家star。]]></content>
      <categories>
        <category>开源组件</category>
      </categories>
      <tags>
        <tag>开源组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native-baidu-map使用及注意问题]]></title>
    <url>%2F2019%2F05%2F06%2Freact-native-baidu-map%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用组件： react-native-baidu-map获取百度地图API_KEY地址：http://lbsyun.baidu.com，在控制台成功创建应用后，就可以看到应用的api key了 安装1yarn add react-native-baidu-map 原生部分Android配置1react-native link react-native-baidu-map 配置AndroidManifest.xml文件1.在中加入如下代码配置开发密钥（AK） 12345&lt;application&gt; &lt;meta-data android:name=&quot;com.baidu.lbsapi.API_KEY&quot; android:value=&quot;开发者 key&quot; /&gt; &lt;/application&gt; 2.在外部添加如下权限声明： 12345678910111213141516171819202122//获取设备网络状态，禁用后无法获取网络状态&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;//网络权限，当禁用后，无法进行检索等相关业务&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;//读取设备硬件信息，统计数据&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;//读取系统信息，包含系统版本等信息，用作统计&lt;uses-permission android:name=&quot;com.android.launcher.permission.READ_SETTINGS&quot; /&gt;//获取设备的网络状态，鉴权所需网络代理&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;//允许sd卡写权限，需写入地图数据，禁用后无法显示地图&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;//这个权限用于进行网络定位&lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot; /&gt;//这个权限用于访问GPS定位&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;//获取统计数据&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;//使用步行AR导航，配置Camera权限&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;//程序在手机屏幕关闭后后台进程仍然运行&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt; IOS配置使用pod,Podfile文件中添加 123456789101112131415pod &apos;React&apos;, :path =&gt; &apos;../node_modules/react-native&apos;, :subspecs =&gt; [ &apos;Core&apos;, &apos;CxxBridge&apos;, &apos;DevSupport&apos;, &apos;RCTText&apos;, &apos;RCTNetwork&apos;, &apos;RCTWebSocket&apos;, &apos;RCTAnimation&apos;]pod &apos;yoga&apos;, :path =&gt; &apos;../node_modules/react-native/ReactCommon/yoga&apos;pod &apos;DoubleConversion&apos;, :podspec =&gt; &apos;../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec&apos;pod &apos;glog&apos;, :podspec =&gt; &apos;../node_modules/react-native/third-party-podspecs/glog.podspec&apos;pod &apos;Folly&apos;, :podspec =&gt; &apos;../node_modules/react-native/third-party-podspecs/Folly.podspec&apos;pod &apos;react-native-baidu-map&apos;, :podspec =&gt; &apos;../node_modules/react-native-baidu-map/ios/react-native-baidu-map.podspec&apos; 注意！！！：AppDelegate.m init 初始化，使用如下代码，可以解决RCTBaiduMapViewManager.h文件找不到的问题12345678#import &lt;react-native-baidu-map/BaiduMapViewManager.h&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; ... // 地图 ak 注册 [BaiduMapViewManager initSDK:@&quot;&quot;]; ...&#125; 使用123456789101112131415161718导入import &#123; MapView, MapTypes, Geolocation, Overlay &#125; from &apos;react-native-baidu-map&apos;const &#123; Marker &#125; = Overlay;&lt;MapView width=&#123;deviceWidth&#125; height=&#123;200&#125; zoom=&#123;18&#125; trafficEnabled=&#123;true&#125; zoomControlsVisible=&#123;true&#125; mapType=&#123;MapTypes.SATELLITE&#125; center=&#123;&#123; longitude: 116.465175, latitude: 39.938522 &#125;&#125;&gt; &lt;Marker title=&apos;中心&apos; location=&#123;&#123;longitude: 116.465175, latitude: 39.938522&#125;&#125; /&gt;&lt;/MapView&gt; 效果，上图]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native安卓打正式包报错]]></title>
    <url>%2F2019%2F04%2F24%2Freact-native%E6%89%93%E5%8C%85%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[笔者在工作开发任务中，最近在进行Android打release包测试时，遇到了如下报错，鼓捣了好久(甚是郁闷)，终于解决了。 ReactNative版本环境如下 问题描述 直接使用react-native run-android运行debug没有问题 在没有添加react-native-spinkit这个第三方库是打包也正常 添加react-native-spinkit第三库，进行run-android debug运行也正常 但是使用cd android &amp;&amp; ./gradlew assembleRelease命令打正式包就build失败了报错信息如下：于是开始Google这个错误，1Daemon: AAPT2 aapt2-3.2.1-4818971-osx Daemon #0 但是各种答案都不能解决这个问题，而且还牵涉出其他的新问题。思来想去，应该是添加的第三库react-native-spinkit出现了问题，终于在issues中找到了答案。原来是第三库中的buildTools,compileSdk 和targetSdk的版本和项目中的对应的版本号不一致导致的。 解决方案如下在项目中android\build.gradle文件中的’allProjects’的下方添加如下代码 12345678910111213141516171819202122232425allprojects &#123; repositories &#123; // Add jitpack repository (added by react-native-spinkit) maven &#123; url &quot;https://jitpack.io&quot; &#125; mavenLocal() google() jcenter() maven &#123; // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm url &quot;$rootDir/../node_modules/react-native/android&quot; &#125; &#125;&#125;在allprojects下方添加如下代码 subprojects &#123; afterEvaluate &#123; project -&gt; if (project.hasProperty(&quot;android&quot;)) &#123; android &#123; compileSdkVersion = rootProject.compileSdkVersion buildToolsVersion = rootProject.buildToolsVersion &#125; &#125; &#125; &#125; 打包添加完成后，重新使用cd android &amp;&amp; ./gradlew assembleRelease 命令进行打包就顺利成功的打包了，成功截图如下]]></content>
      <tags>
        <tag>“ReactNative”</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot入门系列HelloWorld]]></title>
    <url>%2F2019%2F02%2F25%2FSpringBoot%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97HelloWorld%2F</url>
    <content type="text"><![CDATA[根据咱们程序员学习的惯例，学习一门新技术都是从HelloWorld开始的。感觉编程是一件非常富有意义的事情，程序员也是一群可爱的人，渴望被关怀和关注，因为我们总在和世界say Hi.好了进入正题 创建项目首先创建一个项目，可看我上一篇文章写得IntelliJ IDEA创建第一个Spring boot项目接下来运行这个项目，你将会看到如下页面提示我们当前没有准确的映射，所以找不到对应的页面也就是404。莫慌，接下来咱们处理一下 创建HelloController控制器在项目名/src/main/java/包名下，新建一个config包，包下面创建HelloController 12345678910111213@Controllerpublic class HelloController &#123; @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET) @ResponseBody public String hello()&#123; return &quot;Hello World&quot;; &#125;&#125;注解说明：@Controller: 可让项目扫描自动检测到这个类,处理http请求@ RequestMapping 请求的路由映射，访问的路径就是：http://localhost:8080/hellovalue: 路由名method: 请求方式，GET,POST,PUT,DELETE等 重新启动项目1访问：http://localhost:8080/hello, 就看到Hello World了 看到如上图所示，就表示我们的hello world成功了。 目录结构： src/main/java: Java代码的目录 src/main/resources: 资源目录 src/test/java: 测试代码的目录 src/test/resources: 测试资源目录 文件说明pom.xml文件父项目 1234567&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;管理Spring Boot应用里面所依赖的版本 管理依赖 1234567891011121314&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来，要用什么功能就导入什么场景的启动器 主程序类，入口类@SpringBootApplication : Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native 0.58 正式版发布]]></title>
    <url>%2F2019%2F01%2F25%2FReactNative0.58%E6%AD%A3%E5%BC%8F%E7%89%88%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[原文地址：https://github.com/react-native-community/react-native-releases/blob/master/CHANGELOG.md#0580本文由简书作者凌宇之蓝翻译,因本人水平有限，难免翻译有误，还望各位见谅。##[0.58.0]欢迎阅读2019年1月发布的React Native。此版本有许多重大变化，我们特别提请您注意： 核心组件的流程类型的现代化和加强 中断对ScrollView，CameraRollView和SwipeableRow的更改，使其在某些方法中不再绑定到组件实例 支持WebKit中的相互TLS 从/ assets之外的目录提供的资产 针对意外行为的大量崩溃修复和解决方案 感谢那些对我们的发布候选人提供反馈的人。如果您有兴趣帮助评估我们的下一个版本，请在此处查看我们的跟踪问题。 ##新增 添加对publicPath的支持以启用来自不同位置的静态资产（0b31496 by @gdborton）####Android 现在可以使用Android系统属性设置Bundler服务器主机，以便在多个应用程序或应用程序安装中更轻松地进行调试adb shell setprop metro.host（@stepanhruda的e02a154） Native Modules现在可以使用额外的属性（userInfo）附加WritableMap arg来拒绝承诺。请参阅Promise.java中定义的接口以获取可用的方法。这可以在JavaScript中以Error.userInfo形式访问。这是为了匹配iOS现有的Error.userInfo行为。有关示例，请参阅PR。（@Salakar＃20940） Native Modules现在将nativeStackAndroid属性暴露给使用Exception / Throwable拒绝的promise - 使Javascript内的本机错误堆栈可用：Error.nativeStackAndroid。这是为了匹配iOS现有的Error.nativeStackIOS支持。有关示例，请参阅PR。（@Salakar＃20940）####IOS 将moduleForName：lazilyLoadIfNecessary添加到RCTBridge.h以按名称查找模块并强制加载它们，以及对@dhahidehpour，@ fkgozali和@mmmulani进行的LazyLoading的各种改进 当使用WebKit = {true}进行相互TLS身份验证时，将WebView的功能添加到setClientAuthenticationCredential（8911353 by @mjhu）##Changed 核心组件的Flow类型的主要改进 许多公共组件都转换为ES6类 Flow依赖现在为v0.86.0 metro依赖现在是v0.49.1 jest依赖现在是v24.0.0-alpha.6 fbjs-scripts依赖现在是v1.0.0（＃21880） folly的依赖现在是v2018.10.22.00 React sync for revisions 热重新加载时清理的错误消息 允许CxxModules实现需要两次回调的函数###突破性变化 转换为ES6类的组件的公共方法不再绑定到其组件实例。对于ScrollView，受影响的方法是setNativeProps，getScrollResponder，getScrollableNode，getInnerViewNode，scrollTo，scrollToEnd，scrollWithoutAnimationTo和flashScrollIndicators。对于CameraRollView，受影响的方法是：rendererChanged。对于SwipeableRow，受影响的方法是：close。因此，通过引用将这些方法作为回调传递给函数已不再安全。组件实例的自动绑定方法是createReactClass的一种行为，我们决定在切换到ES6类时不保留这种行为。####Android 优化PlatformConstants.ServerHost，PlatformConstants.isTesting和PlatformConstants.androidID以获得性能####IOS 禁止关于本地模块缺少导出的黄色框 ##移除 移除 UIManager.measureViewsInRect()##修复bug 修复Yoga JNI绑定中潜在的UI线程停顿方案 修复因桥接cxx模块注册表周围的竞争条件而发生崩溃的问题 修复视图和文本的displayName;显示特定名称而不是通用“组件” 修复react-native init –help，使其不返回undefined 修复react-native –sourceExts 修复当可见道具未定义或为空时意外显示模态 修复VirtualizedList分页期间的崩溃 修复使用远程调试和Delta捆绑包删除模块可能导致堆栈跟踪不正确的情况####Android具体修复bug: 删除根节点时修复崩溃 修复各种ReactInstanceManager死锁和竞争条件 解除ReactModalHostView和DialogManager时修复IllegalArgumentException 使用Android Gradle Plugin 3.2修复不正确的合并资产路径 在onoutout回调时修复HTTP连接 当远程服务器启动关闭时，修复websocket正确关闭 修复Android 16设备的兼容性问题 修复了在加载源时不遵守Image.resizeMode的问题，从而导致意外填充 修复Android 28的倒置ScrollView，使动量处于正确的方向####IOS具体修复bug: 修复内联视图内容未被重新传输的情况 修复使用前置摄像头时ImagePickerIOS图像不一致的问题 修复竞争条件并在关闭iOS 11及更早版本的JSC时崩溃 修复NetInfo的_firstTimeReachability中的崩溃 修复内联视图可见的情况，即使它应该被截断 使用与内容偏移相关的ScrollView修复崩溃]]></content>
      <categories>
        <category>科技资讯</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA创建第一个Spring boot项目]]></title>
    <url>%2F2019%2F01%2F21%2FSpringboot%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[首先下载maven：http://maven.apache.org/download.cgi 开发工具：IntelliJ IDEAJDK: Java JDK1.8 1.为了第一个项目初始化速度加快，我们先来配置maven:添加配置：选择Build,Execution,Deployment下， Bulid Tools下的Maven,在勾选右边红框中的Override,选择你下载后的文件夹中的settings.xml 2.使用IntelliJ IDEA创建springboot项目1.创建新项目2.选择spring，选择jdk1.83.填写group ，选择packaging— War, 选择Next4.选择Web, 点击Next,下一步点击finish就好了。5.等着项目初始化完成就可以了。6.在项目的applicaiton右键，选择Run “DemoApplication” 运行成功的截图： 我的网站：https://wayne214.github.io]]></content>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记之三排序和过滤]]></title>
    <url>%2F2019%2F01%2F21%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%E6%8E%92%E5%BA%8F%E5%92%8C%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[在数据库的使用中排序和过滤也是经常的操作 排序检索数据,关键字order ##1.按照某个列名排序 12345678910111213141516171819202122普通排序mysql&gt; select * from user;+----+--------+-----+-----------------------+-----+| id | name | age | address | sex |+----+--------+-----+-----------------------+-----+| 1 | 张三 | 20 | 北京海底市南区 | 1 || 2 | 李四 | 22 | 北京海底市南区 | 1 || 3 | 赵芸 | 32 | 上海市徐汇区 | 2 || 4 | 王丽 | 31 | 广州厦门 | 2 |+----+--------+-----+-----------------------+-----+4 rows in set (0.00 sec)按照列名name排序是什么样呢？mysql&gt; select * from user order by name;+----+--------+-----+-----------------------+-----+| id | name | age | address | sex |+----+--------+-----+-----------------------+-----+| 1 | 张三 | 20 | 北京海底市南区 | 1 || 2 | 李四 | 22 | 北京海底市南区 | 1 || 4 | 王丽 | 31 | 广州厦门 | 2 || 3 | 赵芸 | 32 | 上海市徐汇区 | 2 |+----+--------+-----+-----------------------+-----+4 rows in set (0.00 sec) ##2.按照多个列名排序 12345678910mysql&gt; select * from user order by name, age;+----+--------+-----+-----------------------+-----+| id | name | age | address | sex |+----+--------+-----+-----------------------+-----+| 1 | 张三 | 20 | 北京海底市南区 | 1 || 2 | 李四 | 22 | 北京海底市南区 | 1 || 4 | 王丽 | 31 | 广州厦门 | 2 || 3 | 赵芸 | 32 | 上海市徐汇区 | 2 |+----+--------+-----+-----------------------+-----+4 rows in set (0.00 sec) ##3.指定排序方向，默认为字母(a-z),升序 1234567891011使用关键字desc,可以改为降序排列mysql&gt; select * from user order by name desc;+----+--------+-----+-----------------------+-----+| id | name | age | address | sex |+----+--------+-----+-----------------------+-----+| 3 | 赵芸 | 32 | 上海市徐汇区 | 2 || 4 | 王丽 | 31 | 广州厦门 | 2 || 2 | 李四 | 22 | 北京海底市南区 | 1 || 1 | 张三 | 20 | 北京海底市南区 | 1 |+----+--------+-----+-----------------------+-----+4 rows in set (0.00 sec) ##4.和limit配合使用，限制检索数据数量 123456789mysql&gt; select * from user order by name limit 3;+----+--------+-----+-----------------------+-----+| id | name | age | address | sex |+----+--------+-----+-----------------------+-----+| 1 | 张三 | 20 | 北京海底市南区 | 1 || 2 | 李四 | 22 | 北京海底市南区 | 1 || 4 | 王丽 | 31 | 广州厦门 | 2 |+----+--------+-----+-----------------------+-----+3 rows in set (0.00 sec) 数据过滤，关键字where ##1.检索某一条记录 1234567891011121314151617181920mysql&gt; select * from user where id = 2;+----+--------+-----+-----------------------+-----+| id | name | age | address | sex |+----+--------+-----+-----------------------+-----+| 2 | 李四 | 22 | 北京海底市南区 | 1 |+----+--------+-----+-----------------------+-----+1 row in set (0.00 sec)和order by 配合使用mysql&gt; select * from user where id &lt;4 order by name limit 3;+----+--------+-----+-----------------------+-----+| id | name | age | address | sex |+----+--------+-----+-----------------------+-----+| 1 | 张三 | 20 | 北京海底市南区 | 1 || 2 | 李四 | 22 | 北京海底市南区 | 1 || 3 | 赵芸 | 32 | 上海市徐汇区 | 2 |+----+--------+-----+-----------------------+-----+3 rows in set (0.00 sec)关于where子句的位置: 在同时使用where和order by子句时候, 我们应该让order by位于where 子句之后。 ##2.范围检索–between 123456789mysql&gt; select * from user where id between 2 and 4;+----+--------+-----+-----------------------+-----+| id | name | age | address | sex |+----+--------+-----+-----------------------+-----+| 2 | 李四 | 22 | 北京海底市南区 | 1 || 3 | 赵芸 | 32 | 上海市徐汇区 | 2 || 4 | 王丽 | 31 | 广州厦门 | 2 |+----+--------+-----+-----------------------+-----+3 rows in set (0.00 sec) ##3.过滤–组合where 12345678mysql&gt; select * from user where id &gt;1 and id &lt; 4;+----+--------+-----+-----------------------+-----+| id | name | age | address | sex |+----+--------+-----+-----------------------+-----+| 2 | 李四 | 22 | 北京海底市南区 | 1 || 3 | 赵芸 | 32 | 上海市徐汇区 | 2 |+----+--------+-----+-----------------------+-----+2 rows in set (0.00 sec) 4. 数据过滤–or 操作符123456789mysql&gt; select * from user where id &lt;2 or id &gt;=3;+----+--------+-----+-----------------------+-----+| id | name | age | address | sex |+----+--------+-----+-----------------------+-----+| 1 | 张三 | 20 | 北京海底市南区 | 1 || 3 | 赵芸 | 32 | 上海市徐汇区 | 2 || 4 | 王丽 | 31 | 广州厦门 | 2 |+----+--------+-----+-----------------------+-----+3 rows in set (0.00 sec) ##5.数据过滤–in 操作符 123456789101112131415in操作符可以用于指定操作范围，范围内每个条件都可以进行匹配。mysql&gt; select * from user where name in (&quot;张三&quot;,&quot;李四&quot;);+----+--------+-----+-----------------------+-----+| id | name | age | address | sex |+----+--------+-----+-----------------------+-----+| 1 | 张三 | 20 | 北京海底市南区 | 1 || 2 | 李四 | 22 | 北京海底市南区 | 1 |+----+--------+-----+-----------------------+-----+2 rows in set (0.00 sec)in操作符的优势：1. 使用长的合法选项清单时候, in操作符比较直观。2. in操作符计算的次序比较好管理3. in操作符一般比or操作符效率快4. in操作符可以包括其他select语句，能够更加动态的创建where子句 ##6.数据过滤–not操作符 1234567891011not操作符只有一个特点, 就是否定它后面的任何条件。mysql支持not对in, between, exists子句取反。mysql&gt; select * from user where name not in (&quot;张三&quot;,&quot;李四&quot;);+----+--------+-----+--------------------+-----+| id | name | age | address | sex |+----+--------+-----+--------------------+-----+| 3 | 赵芸 | 32 | 上海市徐汇区 | 2 || 4 | 王丽 | 31 | 广州厦门 | 2 |+----+--------+-----+--------------------+-----+2 rows in set (0.00 sec)]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记之二]]></title>
    <url>%2F2019%2F01%2F17%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[数据库的操作总结就是：增删改查(CURD),今天记录一下基础的检索查询工作。 检索MySQL 1.查询表中所有的记录123456789mysql&gt; select * from apps;+----+------------+-----------------------+---------+| id | app_name | url | country |+----+------------+-----------------------+---------+| 1 | QQ APP | http://im.qq.com | CN || 2 | 微博 APP | http://weibo.com | CN || 3 | 淘宝 APP | http://www.taobao.com | CN |+----+------------+-----------------------+---------+3 rows in set (0.00 sec) 2. 查询表中某列(单列)的记录123456789mysql&gt; select app_name from apps;+------------+| app_name |+------------+| QQ APP || 微博 APP || 淘宝 APP |+------------+3 rows in set (0.00 sec) 3.检索表中多列的记录,列名之间用逗号分开123456789mysql&gt; select id, app_name from apps;+----+------------+| id | app_name |+----+------------+| 1 | QQ APP || 2 | 微博 APP || 3 | 淘宝 APP |+----+------------+3 rows in set (0.00 sec) 4.检索不重复的记录，distinct关键字1234567891011121314151617181920mysql&gt; select * from apps;+----+------------+-----------------------+---------+| id | app_name | url | country |+----+------------+-----------------------+---------+| 1 | QQ APP | http://im.qq.com | CN || 2 | 微博 APP | http://weibo.com | CN || 3 | 淘宝 APP | http://www.taobao.com | CN || 4 | QQ APP | http://im.qq.com | CN |+----+------------+-----------------------+---------+4 rows in set (0.00 sec)上面表中是所有的数据，可以看到第1条和第4条数据是一样的，如果想要检索时不想出现重复的数据，可以使用distinct关键字，并且需要放在所有列的前面mysql&gt; select distinct app_name from apps;+------------+| app_name |+------------+| QQ APP || 微博 APP || 淘宝 APP |+------------+3 rows in set (0.00 sec) 5.限制检索记录的数量， limit关键字123456789101112131415161718mysql&gt; select * from apps limit 2;+----+------------+------------------+---------+| id | app_name | url | country |+----+------------+------------------+---------+| 1 | QQ APP | http://im.qq.com | CN || 2 | 微博 APP | http://weibo.com | CN |+----+------------+------------------+---------+2 rows in set (0.00 sec)limit后面可以跟两个值, 第一个为起始位置, 第二个是要检索的行数mysql&gt; select * from apps limit 1, 2;+----+------------+-----------------------+---------+| id | app_name | url | country |+----+------------+-----------------------+---------+| 2 | 微博 APP | http://weibo.com | CN || 3 | 淘宝 APP | http://www.taobao.com | CN |+----+------------+-----------------------+---------+2 rows in set (0.00 sec) 5.limit关键字和offset配合使用123456789limit可以配合offset使用, 如limit 2 offset 1(从行1开始后的2行,默认行数的角标为0)mysql&gt; select * from apps limit 2 offset 1;+----+------------+-----------------------+---------+| id | app_name | url | country |+----+------------+-----------------------+---------+| 2 | 微博 APP | http://weibo.com | CN || 3 | 淘宝 APP | http://www.taobao.com | CN |+----+------------+-----------------------+---------+2 rows in set (0.00 sec)]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记之一]]></title>
    <url>%2F2019%2F01%2F16%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL 是开源的，所以你不需要支付额外的费用。 MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL 使用标准的 SQL 数据语言形式。 MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。 MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。 MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。 MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。 学习的开发环境： Mac, MySQL, Navicat(可视化SQL工具)Mac 安装MySQL数据库方式Mac使用brew(Homebrew)安装mysql，附 Mac Nacicat Premium 破解版 注意：Mysql对大小写不敏感, SQL语句末尾加分号“；” 使用MySQL 1.命令行连接MySQL服务器12mysql -u root -pEnter password:****** 2.创建数据库database1mysql&gt; create DATABASE [数据库名称]; 3.删除数据库1mysql&gt; drop DATABASE [数据库名称]; 4.选择或切换数据库 12mysql&gt; use RUNOOB;Database changed 5.查看当前数据库12345678910mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || runoob || sys |+--------------------+ 6.查看一个数据库中的所有的表12345678910111213mysql&gt; use runoob;Database changedmysql&gt; show tables;+------------------+| Tables_in_runoob |+------------------+| apps || employee || runoob_tbl || tcount_tbl || websites |+------------------+5 rows in set (0.00 sec) 7. 查看表中所有的列：12345678910mysql&gt;show columns from apps;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(10) | NO | PRI | NULL | || app_name | varchar(20) | NO | | NULL | || url | varchar(40) | NO | | NULL | || country | varchar(20) | NO | | NULL | |+----------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 8. 查看创建表的sql语句：12345678910111213mysql&gt; show create table apps;+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| apps | CREATE TABLE `apps` ( `id` int(10) NOT NULL, `app_name` varchar(20) NOT NULL, `url` varchar(40) NOT NULL, `country` varchar(20) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 |+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 9. 查询创建数据库的sql语句1234567mysql&gt; show create database runoob;+----------+-----------------------------------------------------------------+| Database | Create Database |+----------+-----------------------------------------------------------------+| runoob | CREATE DATABASE `runoob` /*!40100 DEFAULT CHARACTER SET utf8 */ |+----------+-----------------------------------------------------------------+1 row in set (0.00 sec)]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ReactNative0.56版本Flatlist列表内容跳动的问题]]></title>
    <url>%2F2019%2F01%2F04%2Freact-native%E5%88%97%E8%A1%A8%E5%86%85%E5%AE%B9%E8%B7%B3%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[Reactnative的版本升级一直是一个工作量比较的大的事情，每次升级都可能伴随着很多的坑。前段时间在升级到0.56版本的时候发现一个问题，在flatlist使用中，加载多页后，列表项内容开始进行上下抖动的乱跳，疯了一样。于是开始上react-native的issues上寻找答案，有通过查看官方的版本升级日志找到了答案：react-native升级日志0.57在其中看到如下bugFix描述： 因为Flatlist继承自VirtualizedList,所以就豁朗开朗了。解决方案：将ReactNative Version升级到0.57以上版本就好了官方升级方案,推荐第一种“基于 Git 的自动合并更新”的升级方案。]]></content>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Taro小程序采坑记]]></title>
    <url>%2F2018%2F12%2F24%2FTaro%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%87%87%E5%9D%91%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Taro，京东凹凸实验室出品的适配多端的一个框架，Taro 是一套遵循 React 语法规范的 多端开发 解决方案。现如今市面上端的形态多种多样，Web、React-Native、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、RN 等）运行的代码。 But 理想很丰满，现实很骨感最近在尝试采用其编写小程序代码，发现采坑的地方不少 ##事件处理bind函数，不能传值了？ Taro 目前暂时不支持通过匿名函数传值，也不支持多层 lambda 嵌套。当你有传参需求时，请全部使用 bind 来处理。更新了@tarojs/cli为最新版后，发现bind的方法不能传值了 1&lt;Button onClick=&#123;this.goto.bind(this,&apos;111&apos;)&#125;&gt;跳转详情页&lt;/Button&gt; 打印出来的是这个鬼：根本不是传递的字符串根据issues中提供的方式： cli 和项目依赖都要升级到 1.2.1使用命令行更新cli及项目依赖后能够正常传值了 1taro update project]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative生命周期]]></title>
    <url>%2F2018%2F12%2F14%2FReactNative%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[1.组件实例化阶段defaultProps:设置组件的初始属性值，比如设置默认Color,width等，可以在通过this.props获取相应的值 constructor(props):这里通过this.props可以获取defaultProps设置的默认属性值，同时这里用于初始化控件的可变化的变量，通过this.state设置变量的初始值，通过this.setState()函数修改变量的值，调用render()函数重新渲染页面，得到新的页面 componentWillMount： 组件将要被加载到视图之前调用 render(): 第一次被调用，用于渲染页面componentDidMount：在调用了render方法，组件加载完成并被成功渲染出来之后，所要执行的后续操作，一般都会在这个函数中进行，比如经常要面对的网络请求等加载数据操作，因为UI渲染是异步的，所以在这个函数里面进行网络请求，能够避免出现UI错误。 2.组件运行时阶段组件的属性prop和状态state任何一个改变都可能会触发render()函数渲染页面 componentWillReceiveProps:指父元素对组件的props进行了修改 shouldComponentUpdate一般用于优化性能，通过业务逻辑判断返回true或false，来决定页面是否进行重新绘制，默认返回true,执行后面两个周期函数 componentWillUpdate:组件刷新前调用 componentDidUpdate：更新后 3.页面卸载页面：componentWillUnmount一般用于清理工作，比如移除事件监听，取消定时器等 4.生命周期函数调用次数 特别提示：更新state必须使用setState()函数，setState是一个异步的函数：setState(update,[callback])setState()不是立刻更新组件。其可能是批处理或推迟更新。这使得在调用setState()后立刻读取this.state的一个潜在陷阱。代替地，使用componentDidUpdate或一个setState回调（setState(updater, callback)），当中的每个方法都会保证在更新被应用之后触发。 参考文档：https://react.docschina.org/docs/react-component.html]]></content>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS下安装MongoDB数据库]]></title>
    <url>%2F2018%2F12%2F11%2FMacOS%E4%B8%8B%E5%AE%89%E8%A3%85MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[官方链接：Install MongoDB Community Edition on macOS推荐大家使用Homebrew安装##1.更新 Homebrew’s 包版本 1brew update ##2.安装MongoDB 1brew install mongodb 休息片刻，等他安装完就好了默认安装在/usr/local/Cellar/mongodb/4.0.4_1（我的版本）目录下安装好了，还需要配置一下，否则是无法正常启动服务的 ##3.配置mongodb####a.创建一个db目录，用于mongodb写数据 1mkdir -p /data/db 如果出现 permission denied ，加上 sudo 命令： 1sudo mkdir -p /data/db ####b.给 /data/db 文件夹赋予权限 12345sudo chown id -u /data/db如果出现 &quot;illegal user name&quot; 的错误提示，这时我们可以查看当前的 username 并赋予权限：$ whoamiusername$ sudo chown username /data/db ####c.配置mongodb环境变量1.打开.zshrc 文件 12345vim ~/.zshrc添加mongodb的安装目标到path中export PATH=/usr/local/Cellar/mongodb/4.0.4_1/bin:$&#123;PATH&#125;使配置生效source ~/.zshrc 2.修改 MongoDB 配置文件, 配置文件默认在 /usr/local/etc 下的 mongod.conf： 123456789# Store data in /usr/local/var/mongodb instead of the default /data/dbdbpath = /data/db# Append logs to /usr/local/var/log/mongodb/mongo.loglogpath = /usr/local/var/log/mongodb/mongo.loglogappend = true# Only accept local connectionsbind_ip = 127.0.0.1 3.启动mongod服务 1mongod 当出现上图红框中的命令时，就表明服务启动成功了，侦听端口为27017，这是mongod的默认端口，在另外的一个窗口中使用mongo就可以打开客户端： 1mongo 这时候就可输入数据库命令进行操作了，比如show dbs,可以查看当前的数据库集合了 我的网站：https://wayne214.github.io]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native底部导航快速切换时轮播图空白]]></title>
    <url>%2F2018%2F12%2F11%2Freact-native%E8%BD%AE%E6%92%AD%E5%9B%BE%E7%A9%BA%E7%99%BD%2F</url>
    <content type="text"><![CDATA[目前react-native平台最好用的轮播图组件：react-native-swiper 最近在项目迭代开发测试中发现一个问题，就是在快速切换APP底部tab导航栏时，集成的轮播图组件react-native-swiper会白屏，无法显示图片如下图所示： 通过查找react-native-swiper的issues发现了，也有人遇到这个问题，最终找到了解决方案：给组件Swiper添加一个属性即可： 1removeClippedSubviews=&#123;false&#125; 添加位置如图所示：]]></content>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb图形可视化客户端-robo 3T]]></title>
    <url>%2F2018%2F12%2F10%2F3T%2F</url>
    <content type="text"><![CDATA[1.官网下载地址：https://robomongo.org 选择Download Robo 3T2.下载完成之后，打开后点击左上角的 create创建一个连接，给该连接起个名字，如：localhost, 使用默认地址 localhost 和 端口27017 即可，点击save保存。如下图所示： 3.使用默认设置，点击save保存即可，会出现如下页面 4.点击Connect连接MongoDb数据库，就可以看到如下的页面了 5.右键数据库打开shell命令面板 6.打开后显示如下页面，输入如下命令，向数据库中添加一条数据 7.可以查看到刚才添加的数据 当然可以进行其他的增删改查操作。 使用图形化的工具操作Mongodb数据库是不是很爽呀。]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter1.0正式版发布]]></title>
    <url>%2F2018%2F12%2F10%2FFlutter%E5%8F%91%E5%B8%831.0%E6%AD%A3%E5%BC%8F%E7%89%88%2F</url>
    <content type="text"><![CDATA[今天我们非常高兴的宣布，Flutter 的 1.0 版本正式发布！Flutter 是 Google 为您打造的 UI 工具包，帮助您通过一套代码同时在 iOS 和 Android 上构建媲美原生体验的精美应用！ 如今，移动开发者们在同时兼容 iOS 和 Android 时有两种选择：走原生开发路线，把界面和逻辑在不同平台分别实现；抑或用同一套代码兼容多个平台，但这往往意味着运行速度和产品保真度的损失。我们坚信，Flutter 为您提供了一套两全其美的解决方案——既能用原生 ARM 代码直接调用的方式来加速图形渲染和 UI 绘制，又能同时运行在两大主流移动操作系统上。Flutter 1.0 正式版: Google 的便携 UI 工具包 4个特点：Flutter 可以帮助您构建界面精美的应用。我们希望设计师们都能充分发挥自己的想象，尽情施展精美绝伦的创意，而不受框架局限性的干扰。通过 Flutter，您可以在屏幕上有像素级的掌控。Flutter 强大的图像组合能力让您近乎可以不受限制的堆叠任何图形、视频、文本和控件。Flutter 内置了一系列的 widgets (在 Flutter 里，几乎所有内容都是 widget)，这些 widgets 可以帮助您在 iOS 和 Android 上实现极致的视觉体验。Flutter 集成并有最大程度的实现了 Material Design —— 这是 Google 为数字体验所创作的开放的设计系统。 Flutter 的另一个特点的速度快。它基于 Skia 2D 硬件加速图形引擎，该引擎也同样用在了 Chrome 和 Android 平台。媲美原生应用的速度，这是我们在构建 Flutter 时的初心。Flutter 的代码基于 Dart 平台，它可以被编译成 iOS 和 Android 平台上 32 位和 64 位的 ARM 代码。 Flutter 非常高效。Flutter 引入了 Stateful Hot Reload（保持应用状态的热重载），这个革命性的新特性可以让移动开发者和设计师们实时迭代应用程序。通过 Stateful Hot Reload，无需重新启动应用，你就可以在程序运行的时候直接看到代码修改之后的效果，Stateful Hot Reload 改变了开发者们编写应用的方式。在我们的用户反馈中，开发者们表示该特性使得开发效率提升了三倍。 最后，Flutter 是开放的。Flutter 是一个基于 BSD-style 许可的开源项目，全球数百位开发者在为其贡献代码。Flutter 的插件生态系统平台也充满活力。有数千款插件已经发布，避免了重复造轮子。由于 Flutter 应用程序使用标准的 Android 和 iOS 的编译打包工具 (build tools)，因此它的开放还体现在您可以使用原生开发资源。比如，您同样可以在 Android 上使用 Kotlin 或者 Java，在 iOS 上使用 Swift 或者 Objective-C 来写逻辑或者界面。]]></content>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native-webview替代RN原生Core中Webview]]></title>
    <url>%2F2018%2F12%2F04%2Freact-native-webview%E6%9B%BF%E4%BB%A3RN%E5%8E%9F%E7%94%9FCore%E4%B8%ADWebview%2F</url>
    <content type="text"><![CDATA[Warning Please use the react-native-community/react-native-webview fork of this component instead. To reduce the surface area of React Native, &lt;WebView/&gt; is going to be removed from the React Native core. For more information, please read The Slimmening proposal. 一句话就是：使用 react-native-community/react-native-webview 替代。 要被从react-native core中删除了。 现在react-native-webview现在支持Android平台的onShouldStartLoadWithRequest方法了 ##使用方式： 12$ yarn add react-native-webview$ react-native link react-native-webview ##使用案例： 12345678910111213141516import React, &#123; Component &#125; from &quot;react&quot;;import &#123; StyleSheet, Text, View &#125; from &quot;react-native&quot;;import &#123; WebView &#125; from &quot;react-native-webview&quot;;// ...class MyWebComponent extends Component &#123; render() &#123; return ( &lt;WebView source=&#123;&#123; uri: &quot;https://infinite.red/react-native&quot; &#125;&#125; style=&#123;&#123; marginTop: 20 &#125;&#125; onLoadProgress=&#123;e =&gt; console.log(e.nativeEvent.progress)&#125; /&gt; ); &#125;&#125; 如果出现如下报错： Invariant Violation: requireNativeComponent: “RNCWKWebView” was not found in the UIManager 解决方案：###1.将RNCWebView.xcodeproj添加到项目的Libraries中，用Xcode打开项目，在librarie右键点击add Files to 项目中###2.在Build Phases的Link Binary With Libraries中添加libRNCWebView.a文件]]></content>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative入门教程-项目结构解析及HelloWorld]]></title>
    <url>%2F2018%2F11%2F22%2FReactNative%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90%E5%8F%8AHelloWorld%2F</url>
    <content type="text"><![CDATA[今天我们从历史传统“Hello World”开始。 首先创建一个项目, 指定创建0.55.4的版本1react-native init rndemo --version 0.55.4 进入项目中，使用命令yarn install 安装依赖 等待安装完成之后，进入项目根目录，使用如下命令运行到iOS或Android模拟器上，即可看到下面的画面，就表示运行项目成功了 1react-native run-ios or run-android 项目的目录结构如下： 咱们接下来逐一解释一下目录结构的组成部分： 项目结构解析 android: Android的原生开发文件目录，用Android Studio打开项目就是打开这个文件进行原生开发 ios: IOS原生开发目录，使用Xcode打开进行原生开发 node_modules: 使用“npm install”或者“yarn install”，根据项目中package.json配置自动生成的项目依赖库 .babelrc: Babel的配置文件,Babel是一个广泛使用的转码器，主要用来将ES6代码转为ES5代码，从而在现有环境执行。babelrc用来设置转码规则和插件。 .buckconfig: buck的配置文件，buck是Facebook推出的一款高效率的App项目构建工具。 .flowconfig: Flow 是 Facebook 旗下一个为 JavaScript 进行静态类型检测的检测工具。它可以在 JavaScript 的项目中用来捕获常见的 bugs，比如隐式类型转换，空引用等等。 .gitattributes: git属性文件设定一些项目特殊的属性。比如要比较word文档的不同；对strings程序进行注册；合并冲突的时候不想合并某些文件等等。 .gitignore: 用来配置git提交需要忽略的文件。 .watchmanconfig: 用于监控bug文件和文件变化，并且可以出发指定的操作。 App.js：就是编写代码的地方，稍后“hello world”就是在这里进行修改。 app.json: 配置了name和displayName，不过没发现在哪里使用到了。（待研究。。） index.js: iOS和Android项目的统一入口文件，可以在android的MainApplication中的ReactNativeHost中重写getJSMainModuleName()方法更改; 在Ios的AppDelegate.m文件的didFinishLaunchingWithOptions方法中通过jsBundleURLForBundleRoot可以更改入口文件。 package.json: package.json定义了项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。 yarn.lock: Yarn 是 一个由 Facebook 创建的新 JavaScript 包管理器；每次添加依赖或者更新包版本，yarn都会把相关版本信息写入yarn.lock文件。这样可以解决同一个项目在不同机器上环境不一致的问题。 Hello World 修改App.js文件如下： 现在我们已经完成了Hello world， 是不是很简单呢？ 知识点 JSX javascript语法糖 ES6 组件(Component)：上面的代码定义了一个名为HelloWorldApp的新的组件（Component）。你在编写 React Native 应用时，肯定会写出很多新的组件。而一个 App 的最终界面，其实也就是各式各样的组件的组合。组件本身结构可以非常简单——唯一必须的就是在render方法中返回一些用于渲染结构的 JSX 语句]]></content>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native-vector-icons报错问题]]></title>
    <url>%2F2018%2F11%2F20%2Freact-native-vector-icons%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近在写项目的时候，在调试代码的过程中，偶尔会报如下错误，想必好多同学都遇到了，现在记录一下，和大家分享。 1234error: bundling failed: Error: While resolving module `react-native-vector-icons/dist/EvilIcons`, the Haste package `react-native-vector-icons` was found. However the module `dist/EvilIcons` could not be found within the package. Indeed, none of these files exist: * `/Users/user/Desktop/testapp/node_modules/react-native/local-cli/core/__fixtures__/files/dist/EvilIcons(.native||.android.js|.native.js|.js|.android.json|.native.json|.json)` * `/Users/user/Desktop/testapp/node_modules/react-native/local-cli/core/__fixtures__/files/dist/EvilIcons/index(.native||.android.js|.native.js|.js|.android.json|.native.json|.json)` 解决问题第一大法，去github上找到这个项目的issues中，在https://github.com/oblador/react-native-vector-icons/issues/626中看到了解决方案：在项目的根目录下，执行一下如下代码就OK了 1rm ./node_modules/react-native/local-cli/core/__fixtures__/files/package.json]]></content>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序调豆瓣接口api报403错误]]></title>
    <url>%2F2018%2F11%2F20%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%B1%86%E7%93%A3%E6%8E%A5%E5%8F%A3api%E6%8A%A5403%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[笔者最近在开始学习小程序的开发，参考的案例就是豆瓣读书demo,在学习中发现点击banner图看详情的时候，发现服务器返回了430错误，拒绝访问，这不是打消我的积极性嘛，度娘查找资料，终于发现了解决方法，特此记录一下。 将域名更换为https://douban.uieee.com 更换后可以看到已经拿到返回数据： 参考资料：https://blog.csdn.net/yw00yw/article/details/80930204]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python包管理器-pip]]></title>
    <url>%2F2018%2F11%2F20%2FPython%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[pip 是 Python 包管理工具，该工具提供了对Python 包的查找、下载、安装、卸载的功能。 目前如果你在 python.org 下载最新版本的安装包，则是已经自带了该工具。 Python 2.7.9 + 或 Python 3.4+ 以上版本都自带 pip 工具。 pip 官网：https://pypi.org/project/pip/ 你可以通过以下命令来判断是否已安装： 1pip --version 如果没有安装，可使用如下命令进行安装： 12curl https://bootstrap.pypa.io/get-pip.py -o get-pip.pypython get-pip.py 注意： 注意：用哪个版本的 Python 运行安装脚本，pip 就被关联到哪个版本，如果是 Python3 则执行以下命令：$ sudo python3 get-pip.py # 运行安装脚本。一般情况 pip 对应的是 Python 2.7，pip3 对应的是 Python 3.x。 ##pip常用命令获取帮助 1pip --help 查看版本及路径 1pip --version 升级pip的版本 1pip install --upgrade pip 安装包 123pip install SomePackage # 最新版本pip install SomePackage==1.0.4 # 指定版本pip install &apos;SomePackage&gt;=1.0.4&apos; # 最小版本 升级包 1pip install --upgrade SomePackage 卸载包 1pip uninstall SomePackage 参看安装包信息 1pip show 查看指定安装包信息 1pip show -f SomePackage 搜索包 1pip search SomePackage 列出已安装的包 1pip list 查看可升级的包 1pip list -o]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好用到炸的ReactNaitveUI库]]></title>
    <url>%2F2018%2F11%2F19%2F%E5%A5%BD%E7%94%A8%E5%88%B0%E7%82%B8%E7%9A%84ReactNaitveUI%E5%BA%93%2F</url>
    <content type="text"><![CDATA[1.### Beeshell 一个 React Native 应用的基础组件库，基于 0.53.3 版本，提供一整套开箱即用的高质量组件，包含 JS 组件和复合组件（包含 Native 代码），涉及 FE、iOS、Android 三端技术，兼顾通用性和定制化，支持自定义主题，用于开发和服务企业级移动 2.#Teaset React Native UI 组件库, 超过 20 个纯 JS(ES6) 组件, 专注于内容展示和操作控制 3.react-native-ui-lib 4.Ant Design MobileAnt Design 移动端设计规范。antd-mobile 是 Ant Design 的移动规范的 React 实现，服务于蚂蚁及口碑无线业务。 特性 基于 Ant Design 移动设计规范。 规则化的视觉样式配置，适应各类产品风格。 使用 TypeScript 开发，提供类型定义文件。 5.NativeBaseEssential cross-platform UI components for React Native 6.react-native-elements React Native ElementsCross Platform React Native UI Toolkit]]></content>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native升级0.56注意问题]]></title>
    <url>%2F2018%2F11%2F13%2Freact-native%E5%8D%87%E7%BA%A70-56%2F</url>
    <content type="text"><![CDATA[当前项目react-native的版本是0.53.3，因为最近在做一系列性能优化的工作，于是计划升级一下RN的版本，升级至0.56.0。先看一下ReactNative0.56.0版本更新的内容：https://github.com/react-native-community/react-native-releases/blob/master/CHANGELOG.md#056步骤及遇到的问题如下： 1.使用https://reactnative.cn/docs/upgrading/中基于Git的自动合并更新方式：首先全局安装react-native-git-upgrade工具模块： 1$ npm install -g react-native-git-upgrade 2.接下来进行更新操作1234567$ react-native-git-upgrade# 这样会直接把react native升级到最新版本# 或者是：$ react-native-git-upgrade X.Y.Z# 这样把react native升级到指定的X.Y.Z版本 那么更新到0.56.0就是 1$ react-naitve-git-update 0.56.0 3.等待升级结束后，需要解决冲突, 下面的这些文件的冲突都需要进行解决一下 1234567891011121314151617181920212223文件中的冲突会以分隔线隔开，并清楚的标记出处，例如下面这样：13B07F951A680F5B00A75B9A /* Release */ = &#123; isa = XCBuildConfiguration; buildSettings = &#123; ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours CODE_SIGN_IDENTITY = &quot;iPhone Developer&quot;; FRAMEWORK_SEARCH_PATHS = ( &quot;$(inherited)&quot;, &quot;$(PROJECT_DIR)/HockeySDK.embeddedframework&quot;, &quot;$(PROJECT_DIR)/HockeySDK-iOS/HockeySDK.embeddedframework&quot;, );======= CURRENT_PROJECT_VERSION = 1;&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs HEADER_SEARCH_PATHS = ( &quot;$(inherited)&quot;, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include, &quot;$(SRCROOT)/../node_modules/react-native/React/**&quot;, &quot;$(SRCROOT)/../node_modules/react-native-code-push/ios/CodePush/**&quot;, );上面代码中的&quot;ours&quot;表示你自己的代码，而&quot;theirs&quot;表示 React Native 的官方代码。然后你可以根据实际情况判断，选择某一方晋级，另一方出局。 注意问题一、0.56.0以上的RN使用Babel 7 React Native now uses Babel 7When upgrading to 0.56, make sure to bump your babel-preset-react-native package.json dependency to 5.0.2 or newer (but still as fixed value).React Native 现在使用 Babel 7，升级到 0.56 后，请确保将 babel-preset-react-native package.json 依赖项升级到 ^5.0.2 或更高版本。那么就需要升级一下babel-preset-react-native版本 1yarn add babel-preset-react-native@5.0.2 --dev 二、升级后遇到react native version mismatch问题 参考了https://stackoverflow.com/questions/47763824/react-native-version-mismatch中的解决方案：1.IOS进入项目中： 1cd ios &amp;&amp; pod install 12345For others with the same problem on iOS with CocoaPods:I tried all of the solutions above, without luck. I have some packages with native dependencies in my project, and some of those needed pod modules being installed. The problem was that React was specified in my Podfile, but the React pod didn&apos;t automatically get upgraded by using react-native-git-upgrade.The fix is to upgrade all installed pods, by running cd ios &amp;&amp; pod install. 2.Android 第三方库使用的buildToolsVersion版本太低，不需要手动修改库内容，在android/build.gradle中添加以下内容，强制所有依赖使用相同版本。 12345678910subprojects &#123; afterEvaluate &#123;project -&gt; if (project.hasProperty(&quot;android&quot;)) &#123; android &#123; compileSdkVersion 26 buildToolsVersion &apos;26.0.3&apos; &#125; &#125; &#125;&#125; 其他升级问题可参考这篇文章,也可在评论区与我进行沟通。ReactNative从0.47 升级到0.56遇到的问题]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reactnative入门教程-搭建开发环境]]></title>
    <url>%2F2018%2F11%2F08%2Freactnative%E5%B0%8F%E7%99%BD%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[俗话说“工欲善其事，必先利其器”，这对咱们程序猿来说更是如此，强大的开发利器，不仅有助于我们提高开发效率，更能够让我们的开发过程变的舒心。这里我墙裂推荐大家配置一个Mac Book Pro,这简直是程序开发者的神奇。免费打个广告吧：https://item.jd.com/7842699.html, 现在适逢双11，更有优惠活动。正式进入主题。 配置开发环境这里直接推荐ReactNative中文网的配置说明：https://reactnative.cn/docs/getting-started.html 开发IDE响应平台开发软件： Xcode，Android StudioGit命令行优化：item命令控制面板配色这里推荐大家使用WebStorm 进行ReactNative的开发，非常强大的IDE，智能提醒，语法高亮等。使用Windows系统的小伙伴，配置开发环境可参考这篇文章：React Native开发一 webstorm搭建React Native开发环境 注意事项！！！注意！！！：init 命令默认会创建最新的版本，而目前最新的 0.45 及以上版本需要下载 boost 等几个第三方库编译。这些库在国内即便翻墙也很难下载成功，导致很多人无法运行iOS项目！！！中文网在论坛中提供了这些库的国内下载链接。如果你嫌麻烦，又没有对新版本的需求，那么可以暂时创建0.44.3的版本。 1react-native init youprogectname 开在如下表中选择相应的版本号，进行创建项目，比如 1react-native init reactnativeDemo --version 0.44.3 提示：你可以使用–version参数（注意是两个杠）创建指定版本的项目。例如react-native init MyApp –version 0.44.3。注意版本号必须精确到两个小数点。 如果在配置环境的过程中，遇到什么问题，可以在博客下方评论区给我留言，我会第一时间进行回复。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native入门教程-前言]]></title>
    <url>%2F2018%2F11%2F08%2Freactnative%E5%B0%8F%E7%99%BD%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[从17年3月份开始接触ReactNative的开发到现在已经差不多一年半的时间了，在这一年多的时间里，完成从零到壹的过程，也使用ReactNative完成了6、7个APP的开发工作。期间踩了无数的坑，现在打算从零开始写一下怎么入门ReactNative开发。 教程目录索引：ReactNative小白入门教程-搭建开发环境 关于ReactNativeReact Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。 React Native使你能够在Javascript和React的基础上获得完全一致的开发体验，构建世界一流的原生APP。 React Native着力于提高多平台开发的开发效率 —— 仅需学习一次，编写任何平台。(Learn once, write anywhere) ReactNative的发展现状RN作为一款跨平台的开发框架，得到了国内很多公司的支持和使用，比如BATJ都有很多业务采用了RN的方案。RN的版本在稳步的不断迭代，不断修复bug, 丰富插件支持，有更加良好的生态环境，以及十分活跃的开发社区，在github2018年统计的开源项目中，Rn位列第二，仅次于微软的vscode，有理由项目Rn的未来发展将越来越好。有关链接： https://mp.weixin.qq.com/s/S0df_3mm_TOrCVQFcgRmSQ ReactNative重构路线图https://www.oschina.net/news/97129/state-of-react-native-2018https://www.oschina.net/news/101455/react-native-roadmap-2018 后续会推出ReactNative开发入门的系列文章，欢迎关注。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之Activity生命周期]]></title>
    <url>%2F2018%2F11%2F05%2FAndroid%E4%B9%8BActivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[官方Activity生命周期图例： 知识点回顾：1.onStart和onResume,onPause和noStop，从功能描述上差不多，有什么区别？onStart和onStop是从Activity是否可见这个角度回调的，而onResume和onPause是从Activity是否位于前台这个角度来回调的。2.假设当前Activity为A ，如果此时打开了一个新的ActivityB,那么是B的onResume和A的onPause那个先执行？答： 是旧的的Activity先onPause, 然后新Activity再启动。3.当使用ApplicationContext启动standard模式的activity时会报错原因：因为standard模式的Activity会默认进入启动它的Activity任务栈中，但是非Activity类型的Context并没有所谓的任务栈。解决方案：对待启动的activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就会为它创建一个新的任务栈，这时候待启动的Activity实际上是以singleTask模式启动的。 Tips: 系统只在Activity异常终止的时候才会调用onSaveInstanceState和onRestoreInstanceState来存错和恢复数据，其他情况不会触发这个过程。 如果设置了Activity的configeChanges属性，例如android:configChanges=”orientation|locale|keyboardHidden”,在横竖屏切换的时候，不会重新创建Activity，也就不会重新走Activity的生命周期。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年10款好用的PythonIDE]]></title>
    <url>%2F2018%2F11%2F05%2F10%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84PythonIDE%2F</url>
    <content type="text"><![CDATA[Python 非常易学，强大的编程语言。Python 包括高效高级的数据结构，提供简单且高效的面向对象编程。Python 的学习过程少不了 IDE 或者代码编辑器，或者集成的开发编辑器（IDE）。这些 Python 开发工具帮助开发者加快使用 Python 开发的速度，提高效率。高效的代码编辑器或者 IDE 应该会提供插件，工具等能帮助开发者高效开发的特性。这篇文章收集了一些对开发者非常有帮助的，最好的 10 款 Python IDEs。如果你有其他更好的推荐，请在评论和大家分享一下：） VimVim 可以说是 Python 最好的 IDE。Vim 是高级文本编辑器，旨在提供实际的 Unix 编辑器’Vi’功能，支持更多更完善的特性集。Vim 不需要花费太多的学习时间，一旦你需要一个无缝的编程体验，那么就会把 Vim 集成到你的工作流中。 Eclipse with PyDevEclipse 是非常流行的 IDE，而且已经有了很久的历史。Eclipse with Pydev 允许开发者创建有用和交互式的 Web 应用。PyDev 是 Eclipse 开发 Python 的 IDE，支持 Python，Jython和 IronPython 的开发。 Sublime TextSublime Text 是开发者中最流行的编辑器之一，多功能，支持多种语言，而且在开发者社区非常受欢迎。Sublime 有自己的包管理器，开发者可以使用TA来安装组件，插件和额外的样式，所有这些都能提升你的编码体验。 EmacsGNU Emacs 是可扩展，自定义的文本编辑器，甚至是更多的功能。Emacs 的核心是 Emacs Lisp 解析器，但是支持文本编辑。如果你已经使用过 Vim，可以尝试一下 Emacs。 Komodo EditKomodo Edit 是非常干净，专业的 Python IDE。 PyCharmPyCharm 是 JetBrains 开发的 Python IDE。PyCharm用于一般IDE具备的功能，比如， 调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制……另外，PyCharm还提供了一些很好的功能用于Django开发，同时支持Google App Engine，更酷的是，PyCharm支持IronPython！ WingWingware 的 Python IDE 兼容 Python 2.x 和 3.x，可以结合 Django, matplotlib, Zope, Plone, App Engine, PyQt, PySide, wxPython, PyGTK, Tkinter, mod_wsgi, pygame, Maya, MotionBuilder, NUKE, Blender 和其他 Python 框架使用。Wing 支持测试驱动开发，集成了单元测试，nose 和 Django 框架的执行和调试功能。Wing IDE 启动和运行的速度都非常快，支持 Windows, Linux, OS X 和 Python versi。 PyScripterPyScripter 是款免费开源的 Python 集成开发环境（IDE）。 The Eric Python IDEEric 是全功能的 Python 和 Ruby 编辑器和 IDE，是使用 Python 编写的。Eric 基于跨平台的 GUI 工具包 Qt，集成了高度灵活的 Scintilla 编辑器控件。Eric 包括一个插件系统，允许简单的对 IDE 进行功能性扩展。 Interactive Editor for PythonIEP 是跨平台的 Python IDE，旨在提供简单高效的 Python 开发环境。包括两个重要的组件：编辑器和 Shell，并且提供插件工具集从各个方面来提高开发人员的效率。 11.有关其中几个IDE的配置，请参阅菜鸟教程中的文档：http://www.runoob.com/python/python-ide.html]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative文件读写操作]]></title>
    <url>%2F2018%2F11%2F05%2Freactnative%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[最近公司项目要求进行定时上传位置信息，及埋点，因为使用的是RN开发，一开始就是想到在Android和Ios原生里进行操作。在原生里面实现了定时任务，Android里面使用的是broadcastReceive + service + timer实现了。现在需要生成一个日志文件，一开始想在原生里面进行实现文件的读写。后来查找相关资料，发现了一个不错的第三方插件，react-native-fs，现在记录一下，集成步骤及简单的文件读写操作。插件地址：https://github.com/itinance/react-native-fs自己写了个Demo进行了测试，目前没有什么问题,Demo地址https://github.com/wayne214/RNstudyDemo/blob/master/src/utils/readAndWriteFileUtil.js 1.集成安装命令： 1npm install react-native-fs --save //注意：如果react native版本是&lt;0.40安装，使用此标签： 1npm install react-native-fs@2.0.1-rc.2 --save 安装后执行： 1react-native link react-native-fs Android添加相应权限 12&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; 2.使用导入及设置文件存储路径 读写操作 删除文件 获取文件路径 判断文件路径是否存在 拷贝文件 创建目录/创建目录/ mkDir() { const options = { NSURLIsExcludedFromBackupKey: true, // iOS only }; return RNFS.mkdir(destPath, options) .then((res) =&gt; { console.log(&apos;MKDIR success&apos;); }).catch((err) =&gt; { console.log(&apos;err&apos;, err); }); }]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative之Image在Android设置圆角图片变形问题]]></title>
    <url>%2F2018%2F11%2F02%2Freact-native-image%2F</url>
    <content type="text"><![CDATA[ReactNative中的Image使用时比较简单的，比如下面这样： 1234567&lt;Image resizeMode=&apos;contain&apos; defaultSource=&#123;require(&apos;images/avatar_placeholder.png&apos;)&#125; source=&#123;&#123; uri: &apos;http://img1.qimingpian.com/product/raw/2b7285ee83af426c321002e27247377a.jpg&apos; &#125;&#125; style=&#123;&#123;width: 50, height: 50&#125;&#125; /&gt; 效果就是这样了 问题来了，如果给Image设置了圆角了话，Android上就显示有问题了， 1234567891011&lt;Image resizeMode=&apos;contain&apos; defaultSource=&#123;require(&apos;images/avatar_placeholder.png&apos;)&#125; source=&#123;&#123; uri: &apos;http://img1.qimingpian.com/product/raw/2b7285ee83af426c321002e27247377a.jpg&apos; &#125;&#125; style=&#123;&#123; width: 50, height: 50, borderWidth: StyleSheet.hairlineWidth, borderRadius: 3, borderColor: color.STARUP.LINE_BACKGROUND&#125;&#125; /&gt; 就会出现下面的图片变形问题，图片在安卓手机上会出现多余的颜色 怎么解决他呢？如果需要给图片加圆角，解决方案如下： 1.Image不设置圆角，外面用View包裹一下，设置View的圆角12345678910111213&lt;View style=&#123;&#123; width: 50, height: 50, borderWidth: StyleSheet.hairlineWidth, borderRadius: 3, borderColor: color.STARUP.LINE_BACKGROUND&#125;&#125;&gt; &lt;Image resizeMode=&apos;contain&apos; defaultSource=&#123;require(&apos;images/avatar_placeholder.png&apos;)&#125; source=&#123;&#123; uri: &apos;http://img1.qimingpian.com/product/raw/2b7285ee83af426c321002e27247377a.jpg&apos; &#125;&#125; style=&#123;&#123;width: 50, height: 50,&#125;&#125; /&gt; &lt;/View&gt; ##2.设置overlayColor的颜色 12345678910111213&lt;Image resizeMode=&apos;contain&apos; defaultSource=&#123;require(&apos;images/avatar_placeholder.png&apos;)&#125; source=&#123;&#123; uri: &apos;http://img1.qimingpian.com/product/raw/2b7285ee83af426c321002e27247377a.jpg&apos; &#125;&#125; style=&#123;&#123; width: 50, height: 50, borderWidth: StyleSheet.hairlineWidth, borderRadius: 3, borderColor: color.STARUP.LINE_BACKGROUND, overlayColor: &apos;#ffffff&apos; &#125;&#125; /&gt; ok,就酱自了。 都怪自己读书少，没好好看文档：]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨平台的Webview支持onShouldStartLoadWithRequest]]></title>
    <url>%2F2018%2F11%2F02%2Freact-native-webview-crossplatform%2F</url>
    <content type="text"><![CDATA[众所周知，React-Native原生的Webview的属性onShouldStartLoadWithRequest仅支持IOS平台，但是往往在开发中两端都需要进行URl的拦截，进行对应的业务需要。通过不断学习，在https://github.com/react-native-community/react-native-webview 的基础上，整理出来一个方案，并且发布到了npm上，小伙伴们有需要的可以参考一下。https://github.com/wayne214/react-native-webview-crossplatform, 欢迎star,fork. 使用方式如下：1.添加依赖包 yarn add react-native-webview-crossplatformreact-native link react-native-webview-crossplatform 2.在需要的业务页面导入 12345678910111213141516171819202122232425262728import &#123; WebView &#125; from &apos;react-native-webview-crossplatform&apos;export default class webview extends Component&lt;Props&gt; &#123; constructor(props)&#123; super(props); &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;WebView source=&#123;&#123; uri: &apos;https://infinite.red/react-native&apos; &#125;&#125; style=&#123;&#123; marginTop: 20 &#125;&#125; onLoadProgress=&#123;e=&gt;console.log(e.nativeEvent.progress)&#125; onShouldStartLoadWithRequest=&#123;(e)=&gt; &#123; console.log(&apos;拦截&apos;, e) return true &#125;&#125; renderError=&#123;()=&gt; &#123; return &lt;View&gt; &lt;Text&gt;我是错误页面&lt;/Text&gt; &lt;/View&gt; &#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125;]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative集成百度语音合成]]></title>
    <url>%2F2018%2F10%2F31%2FReactNative%E9%9B%86%E6%88%90%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%2F</url>
    <content type="text"><![CDATA[语音交互是现今应用最多的智能交互方式，在人工智能越来越火的当下应用十分广泛，所以特别针对车内环境，在驾驶员安心驾驶的时候，用语音可以安全的进行操控。恰好新版项目中要加入语音播报功能，因为我们的应用和司机有关，于是在网上搜索一些解决方案，目前有阿里云，百度云以及科大讯飞还有一些其他公司提供的相关解决方案。不同方案之间的对比，可以参考下面的文章：智能语音方案比对介绍http://www.jianshu.com/p/95d95f8189aa 目前计划采用的是百度云提供的语音合成技术：有如下几个优势： 1.支持多种语言多种音色支持中文、英文混读，男声、女声、童声、情感男声可供选择，更支持语速、音调、音量、音频码率设置，让应用拥有最甜美和最磁性的声音2.支持离线在线融合模式SDK可以根据当前网络状况及指令的类型，自动判断使用本地引擎还是云端引擎进行语音合成3.合成效果流畅自然语音合成技术业界领先，合成效果接近真人发声，流畅自然，且极具表现力，给你最舒适的听觉体验4.免费额度高 好了，不给它打广告了，开始整干货，下面是集成步骤。先贴上百度云官网文档地址：http://ai.baidu.com/docs#/TTS-Android-SDK/top1.创建一个ReactNative工程，不会的自行百度吧；或者在已有项目中，总之你得有个RN项目2.登录网址百度语音开发者平台注册账号并创建应用：进入控制台–&gt;选择产品服务–&gt;选择人工智能–&gt;创建应用–&gt;填写有关应用信息 同理点击查看Key，查看当前应用的所需的主要三个参数 AppId APIKey SecretKey，后面会用得到. 3.下载相关平台的SDK 4.解压后 BaiduTtsSample:为一个模板代码，eclipse版本的，我就是借鉴里面稍微修改了一下。 data:为百度语音资源，声音文件，它为一个必须文件，中英文资源。最后使用是放在手机物理存储下的。 doc:为一个pdf的简介使用方法以及网络的使用Api文档说明。我们用不到，可以下去读一读的。 libs:为资源jar包和语音引擎文件.so库。也是我们集成必须使用到的。5.接下来的步骤是，我们将语音资源和libs下的资源方法android studio我们的项目里面。将data里面的文件全部复制到Asserts文件夹下。将libs下的两个jar文件复制到项目的libs中,并添加Add As library关联。在项目中的main路径下新建一个jnilibs文件夹，用于放置剩余的libs下的文件。现在的工程目录是(Android) 6.添加权限 7.到此，集成就结束了，接下来就是如何使用。当然可以参照BaiduTtsSample文件夹下的src里面的一个MainActvity的写法。也可以按照下面的总结的工具类来直接使用，方便快捷省事。参考文章：http://blog.csdn.net/bk120/article/details/54020505————————–华丽的分割线—————————-因为咱们的的项目是ReactNative，所以要进行原生和js的交互1.创建一个原生模块是一个继承了ReactContextBaseJavaModule的Java类，它可以实现一些JavaScript所需的功能。 2.注册模块 3.在这个package需要在MainApplication.java文件的getPackages方法中提供。这个文件位于你的react-native应用文件夹的android目录中。 4.为了让你的功能从JavaScript端访问起来更为方便，通常我们都会把原生模块封装成一个JavaScript模块。这不是必须的，但省下了每次都从NativeModules中获取对应模块的步骤。这个JS文件也可以用于添加一些其他JavaScript端实现的功能。 5.使用 6.集成常见问题：百度语音文档中心：http://yuyin.baidu.com/docs/tts/84 Oc 百度语音的ios集成:http://blog.csdn.net/qq_40691827/article/details/78333380iOS 一行代码简单调用百度语音合成:http://www.jianshu.com/p/1c4a3f248098 ps:使用Android原生自带的语音合成：https://github.com/SolveBugs/Utils/blob/master/SpeechUtils.javahttps://blog.csdn.net/csdn_blog_lcl/article/details/52504323]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative仿支付宝付款密码输入框]]></title>
    <url>%2F2018%2F10%2F31%2FReactNative%E4%BB%BF%E6%94%AF%E4%BB%98%E5%AE%9D%E4%BB%98%E6%AC%BE%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86%2F</url>
    <content type="text"><![CDATA[接触RN差不多三个月了，发布一个仿支付宝付款密码的输入框控件，一直都是在使用大神们发布的控件，收益良多，现在发布第一个控件，也是基于一位大神写的控件，站在巨人肩膀上，在此感谢，文中有大神封装的链接，大家可以看看，学习npm发布的步骤，也增加了自己学习的自信心和动力。以后工作中会逐渐发布一些自己写的库，还忘朋友们多多支持。 react-native-password-pay采用React Native开发，仿支付宝付款密码输入框,借鉴了大神封装的类库，在此表示感谢https://github.com/chenchunyong/react-native-passwordInput，采用ES6语法进行改写Install安装包:npm i react-native-password-pay –save 通过引用import Password from ‘react-native-password-pay’来使用Demo 123&lt;View&gt; &lt;Password maxLength=&#123;6&#125;&gt;&lt;/Password&gt; &lt;/View&gt; 其中maxLength={6}表示需要输入6位数密码]]></content>
  </entry>
</search>
